{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable", "NSCopying", "NSSecureCoding"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "getBytes", "class_name": "NSUUID", "method_description": "Returns the UUID as bytes.", "params": [{"param_type": "UnsafeMutablePointer<UInt8>", "param_name": ["uuid"], "param_description": ""}]}], "Vars": [{"var_type": "String", "var_description": "The UUID as a string.", "var_name": "uuidString"}], "subclass_list": [], "class_description": "UUIDs (Universally Unique Identifiers), also known as GUIDs (Globally Unique Identifiers) or IIDs (Interface Identifiers), are 128-bit values. UUIDs created by NSUUID conform to RFC 4122 version 4 and are created with random bytes.\nThe standard format for UUIDs represented in ASCII is a string punctuated by hyphens, for example 68753A44-4D6F-1226-9C60-0050E4C00067. The hex representation looks, as you might expect, like a list of numerical values preceded by 0x. For example, 0xD7, 0x36, 0x95, 0x0A, 0x4D, 0x6E, 0x12, 0x26, 0x80, 0x3A, 0x00, 0x50, 0xE4, 0xC0, 0x00, 0x67. Because a UUID is expressed simply as an array of bytes, there are no endianness considerations for different platforms.\nThe NSUUID class is not toll-free bridged with CoreFoundation\u2019s CFUUID. Use UUID strings to convert between CFUUIDRef and NSUUID, if needed. Two NSUUID objects are not guaranteed to be comparable by pointer value (as CFUUID is); use isEqual(_:) to compare two NSUUID instances.\nImportant\nThe Swift overlay to the Foundation framework provides the UUID structure, which bridges to the NSUUID class. For more information about value types, see Working with Cocoa Frameworks in Using Swift with Cocoa and Objective-C (Swift 4.1).\n", "class_name": "NSUUID"}