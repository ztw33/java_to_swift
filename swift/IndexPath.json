{"subclass_list": [], "Methods": [{"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "!=", "method_description": "Returns a Boolean value indicating whether two values are not equal.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "+", "method_description": "Combines the elements of two index paths into a single index path.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "inout IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "+=", "method_description": "Appends the elements of another index path to this index path.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "", "method_description": "Returns a Boolean that is true if the first index path is less than the second when comparing elements in depth-first traversal order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "==", "method_description": "Returns a Boolean that is true if all nodes of the first index path are equal to those of the second in order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "removeFirst", "method_description": "Removes and returns the first element of the collection.", "return_value": {"return_description": ["The first element of the collection."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "removeFirst", "method_description": "Removes the specified number of elements from the beginning of the collection.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [], "method_name": "removeLast", "method_description": "Removes and returns the last element of the collection.", "return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "removeLast", "method_description": "Removes the given number of elements from the end of the collection.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [], "method_name": "popFirst", "method_description": "Removes and returns the first element of the collection.", "return_value": {"return_description": ["The first element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "popLast", "method_description": "Removes and returns the last element of the collection.", "return_value": {"return_description": ["The last element of the collection if the collection has one or more elements; otherwise, nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "max", "method_description": "Returns the maximum element in the sequence.", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "min", "method_description": "Returns the minimum element in the sequence.", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexPath"}], "method_name": "append", "method_description": "Appends the nodes of another index path to this one.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Array<IndexPath.Element>"}], "method_name": "append", "method_description": "Appends an array of elements to this index path as additional nodes.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexPath.Element"}], "method_name": "append", "method_description": "Appends a single element to this index path as a new node.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexPath.Element"}], "method_name": "appending", "method_description": "Returns a new index path containing the elements of this one plus the given element.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexPath"}], "method_name": "appending", "method_description": "Returns a new index path containing the elements of this one plus those of another index path.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Array<IndexPath.Element>"}], "method_name": "appending", "method_description": "Returns a new index path containing the elements of this one plus an array of additional elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexPath"}], "method_name": "compare", "method_description": "Compares this index path to another in depth-first traversal order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ComparisonResult"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the first element of the sequence.", "return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the given number of initial elements.", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "dropLast", "method_description": "Return a new index path containing all but the last element.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the specified number of final elements.", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "enumerated", "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "IndexPath.Index"}], "method_name": "index", "method_description": "Returns the index that follows the given index.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "IndexPath.Index"}], "method_name": "index", "method_description": "Returns the index that precedes the given index.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "lexicographicallyPrecedes", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "makeIterator", "method_description": "Returns an iterator over the nodes of the index path.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "max", "method_description": "Returns the maximum element in the sequence.", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "min", "method_description": "Returns the minimum element in the sequence.", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "popFirst", "method_description": "Removes and returns the first element of the collection.", "return_value": {"return_description": ["The first element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "popLast", "method_description": "Removes and returns the last element of the collection.", "return_value": {"return_description": ["The last element of the collection if the collection has one or more elements; otherwise, nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["through", "position"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection through the specified position.", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["upTo", "end"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "removeFirst", "method_description": "Removes and returns the first element of the collection.", "return_value": {"return_description": ["The first element of the collection."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "removeFirst", "method_description": "Removes the specified number of elements from the beginning of the collection.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [], "method_name": "removeLast", "method_description": "Removes and returns the last element of the collection.", "return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "removeLast", "method_description": "Removes the given number of elements from the end of the collection.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [], "method_name": "reversed", "method_description": "Returns a view presenting the elements of the collection in reverse order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "sorted", "method_description": "Returns the elements of the sequence, sorted.", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "suffix", "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "suffix", "method_description": "Returns a subsequence from the specified position to the end of the collection.", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the first element of the sequence.", "return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the given number of initial elements.", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "dropLast", "method_description": "Return a new index path containing all but the last element.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the specified number of final elements.", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["IndexPath"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "enumerated", "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "makeIterator", "method_description": "Returns an iterator over the nodes of the index path.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "sorted", "method_description": "Returns the elements of the sequence, sorted.", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "reversed", "method_description": "Returns a view presenting the elements of the collection in reverse order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexPath"}], "method_name": "compare", "method_description": "Compares this index path to another in depth-first traversal order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ComparisonResult"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "lexicographicallyPrecedes", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "", "method_description": "Returns a Boolean that is true if the first index path is less than the second when comparing elements in depth-first traversal order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "==", "method_description": "Returns a Boolean that is true if all nodes of the first index path are equal to those of the second in order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "IndexPath.Index"}], "method_name": "index", "method_description": "Returns the index that follows the given index.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "IndexPath.Index"}], "method_name": "index", "method_description": "Returns the index that precedes the given index.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexPath.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "allSatisfy", "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "compactMap", "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["element"], "param_description": "", "param_type": "Int"}], "method_name": "contains", "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "return_value": {"return_description": ["true if the element was found in the sequence; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "contains", "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "Array<Int>.Index"}, {"param_name": ["to", "end"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "distance", "method_description": "Returns the distance between two indices.", "return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["while", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "drop", "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> IndexPath"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areEquivalent"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Sequence.Element"], "param_description": "", "param_type": "Sequence.Element"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["to", "encoder"], "param_description": "", "param_type": "Encoder"}], "method_name": "encode", "method_description": "", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["isIncluded"], "param_description": "", "param_type": "(Int"}], "method_name": "filter", "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "return_value": {"return_description": ["An array of the elements that isIncluded allowed."], "return_name": [""], "return_type": ["Bool rethrows -> [Int]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "first", "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["of", "element"], "param_description": "", "param_type": "Int"}], "method_name": "firstIndex", "method_description": "Returns the first index where the specified value appears in the collection.", "return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["Array<Int>.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "firstIndex", "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "flatMap", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["String rethrows -> [String]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["body"], "param_description": "", "param_type": "(Int"}], "method_name": "forEach", "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "inout Array<Int>.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}], "method_name": "formIndex", "method_description": "Offsets the given index by the specified distance.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "inout Array<Int>.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}, {"param_name": ["limitedBy", "limit"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "formIndex", "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "inout Array<Int>.Index"}], "method_name": "formIndex", "method_description": "Replaces the given index with its successor.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "inout Array<Int>.Index"}], "method_name": "formIndex", "method_description": "Replaces the given index with its predecessor.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "Array<Int>.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}], "method_name": "index", "method_description": "Returns an index that is the specified distance from the given index.", "return_value": {"return_description": ["An index offset by n from the index i. If n is positive, this is the same value as the result of n calls to index(after:). If n is negative, this is the same value as the result of -n calls to index(before:)."], "return_name": [""], "return_type": ["Array<Int>.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "Array<Int>.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}, {"param_name": ["limitedBy", "limit"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "index", "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["Array<Int>.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "last", "method_description": "Returns the last element of the sequence that satisfies the given predicate.", "return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["of", "element"], "param_description": "", "param_type": "Int"}], "method_name": "lastIndex", "method_description": "Returns the last index where the specified value appears in the collection.", "return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["Array<Int>.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "lastIndex", "method_description": "Returns the index of the last element in the collection that matches the given predicate.", "return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "lexicographicallyPrecedes", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "map", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "map", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "max", "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Bool rethrows -> Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "min", "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Bool rethrows -> Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["by", "belongsInSecondPartition"], "param_description": "", "param_type": "(Int"}], "method_name": "partition", "method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["Bool rethrows -> Array<Int>.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["by", "belongsInSecondPartition"], "param_description": "", "param_type": "(Int"}], "method_name": "partition", "method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["Bool rethrows -> Array<Int>.Index"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["while", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "prefix", "method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> IndexPath"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "randomElement", "method_description": "Returns a random element of the collection.", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "randomElement", "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["initialResult"], "param_description": "", "param_type": "Result"}, {"param_name": ["nextPartialResult"], "param_description": "", "param_type": "(Result"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "reduce", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result rethrows -> Result"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["into", "initialResult"], "param_description": "", "param_type": "Result"}, {"param_name": ["updateAccumulatingResult"], "param_description": "", "param_type": "(inout Result"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "reduce", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["rethrows -> Result"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "reverse", "method_description": "Reverses the elements of the collection in place.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [], "method_name": "shuffle", "method_description": "Shuffles the collection in place.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "shuffle", "method_description": "Shuffles the collection in place, using the given generator as a source for randomness.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [], "method_name": "shuffled", "method_description": "Returns the elements of the sequence, shuffled.", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "shuffled", "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexPath"}, {"params": [], "method_name": "sort", "method_description": "Sorts the collection in place.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "sort", "method_description": "Sorts the collection in place, using the given predicate as the comparison between elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "sorted", "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["Bool rethrows -> [Int]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}, {"param_name": ["whereSeparator", "isSeparator"], "param_description": "", "param_type": "(Int"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["separator"], "param_description": "", "param_type": "Int"}, {"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[IndexPath]"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areEquivalent"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Sequence.Element"], "param_description": "", "param_type": "Sequence.Element"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "Array<Int>.Index"}, {"param_name": ["j"], "param_description": "", "param_type": "Array<Int>.Index"}], "method_name": "swapAt", "method_description": "Exchanges the values at the specified indices of the collection.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexPath"}, {"params": [{"param_name": ["minimum"], "param_description": "", "param_type": "IndexPath"}], "method_name": "...", "method_description": "Returns a partial range extending upward from a lower bound.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeFrom<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["maximum"], "param_description": "", "param_type": "IndexPath"}], "method_name": "...", "method_description": "Returns a partial range up to, and including, its upper bound.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeThrough<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["minimum"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["maximum"], "param_description": "", "param_type": "IndexPath"}], "method_name": "...", "method_description": "Returns a closed range that contains both of its bounds.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ClosedRange<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["maximum"], "param_description": "", "param_type": "IndexPath"}], "method_name": "..", "method_description": "Returns a partial range up to, but not including, its upper bound.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeUpTo<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["minimum"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["maximum"], "param_description": "", "param_type": "IndexPath"}], "method_name": "..", "method_description": "Returns a half-open range that contains its lower bound but not its upper bound.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<IndexPath>"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": "", "method_description": "Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": ">", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": ">", "method_description": "Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": ">=", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexPath"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexPath"}], "method_name": ">=", "method_description": "Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.", "return_value": {"return_description": ["true if lhs is greater than or equal to rhs; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexPath"}], "Vars": [{"var_name": "customMirror", "var_description": "A mirror that reflects the index path.", "var_type": "Mirror"}, {"var_name": "debugDescription", "var_description": "A textual description of the index path suitable for debugging.", "var_type": "String"}, {"var_name": "description", "var_description": "A textual description of the index path.", "var_type": "String"}, {"var_name": "endIndex", "var_description": "One past the index of the last node in the index path.", "var_type": "IndexPath.Index"}, {"var_name": "hashValue", "var_description": "The computed hash value for the index path.", "var_type": "Int"}, {"var_name": "isEmpty", "var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool"}, {"var_name": "item", "var_description": "The value of the item element of the index path.", "var_type": "Int"}, {"var_name": "item", "var_description": "The value of the item element of the index path.", "var_type": "Int"}, {"var_name": "lazy", "var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<IndexPath>"}, {"var_name": "lazy", "var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<IndexPath>"}, {"var_name": "row", "var_description": "The value of the row element of the index path.", "var_type": "Int"}, {"var_name": "section", "var_description": "The value of the section element of the index path.", "var_type": "Int"}, {"var_name": "section", "var_description": "The value of the section element of the index path.", "var_type": "Int"}, {"var_name": "startIndex", "var_description": "The index of the first node in the index path.", "var_type": "IndexPath.Index"}, {"var_name": "isEmpty", "var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool"}, {"var_name": "lazy", "var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<IndexPath>"}, {"var_name": "lazy", "var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<IndexPath>"}, {"var_name": "startIndex", "var_description": "The index of the first node in the index path.", "var_type": "IndexPath.Index"}, {"var_name": "endIndex", "var_description": "One past the index of the last node in the index path.", "var_type": "IndexPath.Index"}, {"var_name": "description", "var_description": "A textual description of the index path.", "var_type": "String"}, {"var_name": "debugDescription", "var_description": "A textual description of the index path suitable for debugging.", "var_type": "String"}, {"var_name": "customMirror", "var_description": "A mirror that reflects the index path.", "var_type": "Mirror"}, {"var_name": "hashValue", "var_description": "The computed hash value for the index path.", "var_type": "Int"}, {"var_name": "count", "var_description": "", "var_type": "Int"}, {"var_name": "count", "var_description": "The number of elements in the collection.", "var_type": "Int"}, {"var_name": "first", "var_description": "The first element of the collection.", "var_type": "Int"}, {"var_name": "indices", "var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<IndexPath>"}, {"var_name": "last", "var_description": "The last element of the collection.", "var_type": "Int"}, {"var_name": "underestimatedCount", "var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "var_type": "Int"}, {"var_name": "underestimatedCount", "var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int"}], "class_name": "IndexPath", "class_inherit_list": [], "interface_list": ["Comparable", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "MutableCollection", "RandomAccessCollection", "ReferenceConvertible"], "class_description": "Each index in an index path represents the index into an array of children from one node in the tree to another, deeper, node.\n", "package_name": "foundation"}