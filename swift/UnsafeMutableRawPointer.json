{"class_inherit_list": [], "Vars": [{"var_description": "", "var_type": "Mirror", "var_name": "customMirror"}, {"var_description": "", "var_type": "PlaygroundQuickLook", "var_name": "customPlaygroundQuickLook"}, {"var_description": "A textual representation of the pointer, suitable for debugging.", "var_type": "String", "var_name": "debugDescription"}], "class_name": "UnsafeMutableRawPointer", "interface_list": ["Comparable", "CustomDebugStringConvertible", "CustomPlaygroundQuickLookable", "CustomReflectable", "Equatable", "Hashable", "Strideable"], "subclass_list": [], "class_description": "The UnsafeMutableRawPointer type provides no automated memory management, no type safety, and no alignment guarantees. You are responsible for handling the life cycle of any memory you work with through unsafe pointers, to avoid leaks or undefined behavior.\nMemory that you manually manage can be either untyped or bound to a specific type. You use the UnsafeMutableRawPointer type to access and manage raw bytes in memory, whether or not that memory has been bound to a specific type.\nThe memory referenced by an UnsafeMutableRawPointer instance can be in one of several states. Many pointer operations must only be applied to pointers with memory in a specific state\u2014you must keep track of the state of the memory you are working with and understand the changes to that state that different operations perform. Memory can be untyped and uninitialized, bound to a type and uninitialized, or bound to a type and initialized to a value. Finally, memory that was allocated previously may have been deallocated, leaving existing pointers referencing unallocated memory.\nRaw memory that has just been allocated is in an uninitialized, untyped state. Uninitialized memory must be initialized with values of a type before it can be used with any typed operations.\nYou can use methods like initializeMemory(as:from:) and moveInitializeMemory(as:from:count:) to bind raw memory to a type and initialize it with a value or series of values. To bind uninitialized memory to a type without initializing it, use the bindMemory(to:count:) method. These methods all return typed pointers for further typed access to the memory.\nMemory that has been bound to a type, whether it is initialized or uninitialized, is typically accessed using typed pointers\u2014instances of UnsafePointer and UnsafeMutablePointer. Initialization, assignment, and deinitialization can be performed using UnsafeMutablePointer methods.\nMemory that has been bound to a type can be rebound to a different type only after it has been deinitialized or if the bound type is a trivial type. Deinitializing typed memory does not unbind that memory\u2019s type. The deinitialized memory can be reinitialized with values of the same type, bound to a new type, or deallocated.\nNote\nA trivial type can be copied bit for bit with no indirection or reference-counting operations. Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enumerations.\nWhen reading from or writing to  memory as raw bytes when that memory is bound to a type, you must ensure that you satisfy any alignment requirements. Writing to typed memory as raw bytes must only be performed when the bound type is a trivial type.\nPointer arithmetic with raw pointers is performed at the byte level. When you add to or subtract from a raw pointer, the result is a new raw pointer offset by that number of bytes. The following example allocates four bytes of memory and stores 0xFF in all four bytes:\nThe code above stores the value 0xFFFF_FFFF into the four newly allocated bytes, and then loads the first byte as a UInt8 instance and the third and fourth bytes as a UInt16 instance.\nAlways remember to deallocate any memory that you allocate yourself.\nWhen calling a function or method with an UnsafeMutableRawPointer parameter, you can pass an instance of that specific pointer type, pass an instance of a compatible pointer type, or use Swift\u2019s implicit bridging to pass a compatible pointer.\nFor example, the print(address:as:) function in the following code sample takes an UnsafeMutableRawPointer instance as its first parameter:\nAs is typical in Swift, you can call the print(address:as:) function with an UnsafeMutableRawPointer instance. This example passes rawPointer as the initial parameter.\nBecause typed pointers can be implicitly cast to raw pointers when passed as a parameter, you can also call print(address:as:) with any mutable typed pointer instance.\nAlternatively, you can use Swift\u2019s implicit bridging to pass a pointer to an instance or to the elements of an array. Use inout syntax to implicitly create a pointer to an instance of any type. The following example uses implicit bridging to pass a pointer to value when calling print(address:as:):\nA mutable pointer to the elements of an array is implicitly created when you pass the array using inout syntax. This example uses implicit bridging to pass a pointer to the elements of numbers when calling print(address:as:).\nImportant\nThe pointer created through implicit bridging of an instance or of an array\u2019s elements is only valid during the execution of the called function. Escaping the pointer to use after the execution of the function is undefined behavior. In particular, do not use implicit bridging when calling an UnsafeMutableRawPointer initializer.\n", "Methods": [{"return_value": {"return_description": ["A pointer offset from this pointer by n bytes."], "return_name": [""], "return_type": ["UnsafeMutableRawPointer"]}, "method_description": "Returns a pointer offset from this pointer by the specified number of bytes.", "method_name": "advanced", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The number of bytes to offset this pointer. n may be positive, negative, or zero.", "param_type": "Int", "param_name": ["by", "n"]}]}, {"return_value": {"return_description": ["A typed pointer to the same memory as this raw pointer."], "return_name": [""], "return_type": ["UnsafeMutablePointer<T>"]}, "method_description": "Returns a typed pointer to the memory referenced by this pointer, assuming that the memory is already bound to the specified type.", "method_name": "assumingMemoryBound", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The type T that the memory has already been bound to.", "param_type": "T.Type", "param_name": ["to"]}]}, {"return_value": {"return_description": ["A typed pointer to the newly bound memory. The memory in this region is bound to T, but has not been modified in any other way. The number of bytes in this region is count * MemoryLayout<T>.stride."], "return_name": [""], "return_type": ["UnsafeMutablePointer<T>"]}, "method_description": "Binds the memory to the specified type and returns a typed pointer to the bound memory.", "method_name": "bindMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The type T to bind the memory to.", "param_type": "T.Type", "param_name": ["to", "type"]}, {"param_description": "The amount of memory to bind to type T, counted as instances of T.", "param_type": "Int", "param_name": ["capacity", "count"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Copies the specified number of bytes from the given raw pointer\u2019s memory into this pointer\u2019s memory.", "method_name": "copyBytes", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A pointer to the memory to copy bytes from. The memory in the region source..<(source + count) must be initialized to a trivial type.", "param_type": "UnsafeRawPointer", "param_name": ["from", "source"]}, {"param_description": "The number of bytes to copy. count must not be negative.", "param_type": "Int", "param_name": ["count"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Copies the specified number of bytes from the given raw pointer\u2019s memory into this pointer\u2019s memory.", "method_name": "copyMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A pointer to the memory to copy bytes from. The memory in the region source..<(source + byteCount) must be initialized to a trivial type.", "param_type": "UnsafeRawPointer", "param_name": ["from", "source"]}, {"param_description": "The number of bytes to copy. byteCount must not be negative.", "param_type": "Int", "param_name": ["byteCount"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Deallocates the previously allocated memory block referenced by this pointer.", "method_name": "deallocate", "class_name": "UnsafeMutableRawPointer", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Deallocates memory referenced by the pointer with the specified size and alignment.", "method_name": "deallocate", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "Int", "param_name": ["bytes"]}, {"param_description": "The alignment of the region to be deallocated, in bytes.", "param_type": "Int", "param_name": ["alignedTo"]}]}, {"return_value": {"return_description": ["The distance from this pointer to x, in bytes."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the distance from this pointer to the given pointer.", "method_name": "distance", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The pointer to calculate the distance to.", "param_type": "UnsafeMutableRawPointer", "param_name": ["to", "x"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The hasher to use when combining the components of this instance.", "param_type": "inout Hasher", "param_name": ["into", "hasher"]}]}, {"return_value": {"return_description": ["A typed pointer to the memory referenced by this raw pointer, offset by index * MemoryLayout<T>.stride bytes."], "return_name": [""], "return_type": ["UnsafeMutablePointer<T>"]}, "method_description": "Initializes the memory referenced by this pointer with the given value, binds the memory to the value\u2019s type, and returns a typed pointer to the initialized memory.", "method_name": "initializeMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The type to bind this memory to.", "param_type": "T.Type", "param_name": ["as", "type"]}, {"param_description": "", "param_type": "Int", "param_name": ["at", "offset"]}, {"param_description": "The number of copies of value to copy into memory. count must not be negative. The default is 1.", "param_type": "Int", "param_name": ["count"]}, {"param_description": "", "param_type": "T", "param_name": ["to", "repeatedValue"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeMutablePointer<C.Element>"]}, "method_description": "", "method_name": "initializeMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "Collection.Element.Type", "param_name": ["as", "type"]}, {"param_description": "", "param_type": "Collection", "param_name": ["from", "source"]}]}, {"return_value": {"return_description": ["A typed pointer to the memory referenced by this raw pointer."], "return_name": [""], "return_type": ["UnsafeMutablePointer<T>"]}, "method_description": "Initializes the memory referenced by this pointer with the values starting at the given pointer, binds the memory to the values\u2019 type, and returns a typed pointer to the initialized memory.", "method_name": "initializeMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The type to bind this memory to.", "param_type": "T.Type", "param_name": ["as", "type"]}, {"param_description": "A pointer to the values to copy. The memory in the region source..<(source + count) must be initialized to type T and must not overlap the destination region.", "param_type": "UnsafePointer<T>", "param_name": ["from", "source"]}, {"param_description": "The number of copies of value to copy into memory. count must not be negative.", "param_type": "Int", "param_name": ["count"]}]}, {"return_value": {"return_description": ["A typed pointer to the memory referenced by this raw pointer."], "return_name": [""], "return_type": ["UnsafeMutablePointer<T>"]}, "method_description": "Initializes the memory referenced by this pointer with the given value, binds the memory to the value\u2019s type, and returns a typed pointer to the initialized memory.", "method_name": "initializeMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The type to bind this memory to.", "param_type": "T.Type", "param_name": ["as", "type"]}, {"param_description": "The instance to copy into memory.", "param_type": "T", "param_name": ["repeating", "repeatedValue"]}, {"param_description": "The number of copies of value to copy into memory. count must not be negative.", "param_type": "Int", "param_name": ["count"]}]}, {"return_value": {"return_description": ["A new instance of type T, read from the raw bytes at offset. The returned instance is memory-managed and unassociated with the value in the memory referenced by this pointer."], "return_name": [""], "return_type": ["T"]}, "method_description": "Returns a new instance of the given type, constructed from the raw memory at the specified offset.", "method_name": "load", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The offset from this pointer, in bytes. offset must be nonnegative. The default is zero.", "param_type": "Int", "param_name": ["fromByteOffset", "offset"]}, {"param_description": "The type of the instance to create.", "param_type": "T.Type", "param_name": ["as", "type"]}]}, {"return_value": {"return_description": ["A typed pointer to the memory referenced by this raw pointer."], "return_name": [""], "return_type": ["UnsafeMutablePointer<T>"]}, "method_description": "Initializes the memory referenced by this pointer with the values starting at the given pointer, binds the memory to the values\u2019 type, deinitializes the source memory, and returns a typed pointer to the newly initialized memory.", "method_name": "moveInitializeMemory", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The type to bind this memory to.", "param_type": "T.Type", "param_name": ["as", "type"]}, {"param_description": "A pointer to the values to copy. The memory in the region source..<(source + count) must be initialized to type T.", "param_type": "UnsafeMutablePointer<T>", "param_name": ["from", "source"]}, {"param_description": "The number of copies of value to copy into memory. count must not be negative.", "param_type": "Int", "param_name": ["count"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Stores the given value\u2019s bytes into raw memory at the specified offset.", "method_name": "storeBytes", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The value to store as raw bytes.", "param_type": "T", "param_name": ["of", "value"]}, {"param_description": "The offset from this pointer, in bytes. offset must be nonnegative. The default is zero.", "param_type": "Int", "param_name": ["toByteOffset", "offset"]}, {"param_description": "The type of value.", "param_type": "T.Type", "param_name": ["as", "type"]}]}, {"return_value": {"return_description": ["A pointer to a newly allocated region of memory. The memory is allocated, but not initialized."], "return_name": [""], "return_type": ["UnsafeMutableRawPointer"]}, "method_description": "Allocates uninitialized memory with the specified size and alignment.", "method_name": "allocate", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The number of bytes to allocate. byteCount must not be negative.", "param_type": "Int", "param_name": ["byteCount"]}, {"param_description": "The alignment of the new region of allocated memory, in bytes.", "param_type": "Int", "param_name": ["alignment"]}]}, {"return_value": {"return_description": ["A pointer to a newly allocated region of memory. The memory is allocated, but not initialized."], "return_name": [""], "return_type": ["UnsafeMutableRawPointer"]}, "method_description": "Allocates uninitialized memory with the specified size and alignment.", "method_name": "allocate", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The number of bytes to allocate. size must not be negative.", "param_type": "Int", "param_name": ["bytes", "size"]}, {"param_description": "The alignment of the new region of allocated memory, in bytes.", "param_type": "Int", "param_name": ["alignedTo", "alignment"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeMutableRawPointer"]}, "method_description": "", "method_name": "+", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "Int", "param_name": ["lhs"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeMutableRawPointer"]}, "method_description": "", "method_name": "+", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "", "method_name": "+=", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "inout UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeMutableRawPointer"]}, "method_description": "", "method_name": "-", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Int"]}, "method_description": "", "method_name": "-", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "", "method_name": "-=", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "inout UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeFrom<UnsafeMutableRawPointer>"]}, "method_description": "Returns a partial range extending upward from a lower bound.", "method_name": "...", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The lower bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["minimum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeThrough<UnsafeMutableRawPointer>"]}, "method_description": "Returns a partial range up to, and including, its upper bound.", "method_name": "...", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The upper bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ClosedRange<UnsafeMutableRawPointer>"]}, "method_description": "Returns a closed range that contains both of its bounds.", "method_name": "...", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The lower bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["minimum"]}, {"param_description": "The upper bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ClosedRange<UnsafeMutableRawPointer>"]}, "method_description": "Returns a countable closed range that contains both of its bounds.", "method_name": "...", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["minimum"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeUpTo<UnsafeMutableRawPointer>"]}, "method_description": "Returns a partial range up to, but not including, its upper bound.", "method_name": "..", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The upper bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<UnsafeMutableRawPointer>"]}, "method_description": "Returns a half-open range that contains its lower bound but not its upper bound.", "method_name": "..", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "The lower bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["minimum"]}, {"param_description": "The upper bound for the range.", "param_type": "UnsafeMutableRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": ["true if lhs references a memory address earlier than rhs; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the first pointer references an earlier memory location than the second pointer.", "method_name": "", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A pointer.", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "Another pointer.", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is less than that of the second argument.", "method_name": "", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["x"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["y"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.", "method_name": "", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": ["true if lhs and rhs reference the same memory address; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two pointers are equal.", "method_name": "==", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A pointer.", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "Another pointer.", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are equal.", "method_name": "==", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["x"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["y"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.", "method_name": ">", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": ["true if lhs is greater than or equal to rhs; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.", "method_name": ">=", "class_name": "UnsafeMutableRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeMutableRawPointer", "param_name": ["rhs"]}]}], "package_name": "swift"}