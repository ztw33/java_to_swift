{"class_description": "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the Collection protocol declares and implements. In addition to the operations that collections inherit from the Sequence protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.\nFor example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.\nThe firstSpace constant is an index into the text string\u2014the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, firstSpace is used to extract the prefix that contains elements up to that index.\nYou can access an element of a collection through its subscript by using any valid index except the collection\u2019s endIndex property. This property is a \u201cpast the end\u201d index that does not correspond with any element of the collection.\nHere\u2019s an example of accessing the first character in a string through its subscript:\nThe Collection protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of text using the first property, which has the value of the first element of the collection, or nil if the collection is empty.\nYou can pass only valid indices to collection operations. You can find a complete set of a collection\u2019s valid indices by starting with the collection\u2019s startIndex property and finding every successor up to, and including, the endIndex property. All other values of the Index type, such as the startIndex property of a different collection, are invalid indices for this collection.\nSaved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the MutableCollection and RangeReplaceableCollection protocols, as well as for the specific type you\u2019re using.\nYou can access a slice of a collection through its ranged subscript or by calling methods like prefix(while:) or suffix(_:). A slice of a collection can contain zero or more of the original collection\u2019s elements and shares the original collection\u2019s semantics.\nThe following example creates a firstWord constant by using the prefix(while:) method to get a slice of the text string.\nYou can retrieve the same slice using the string\u2019s ranged subscript, which takes a range expression.\nThe retrieved slice of text is equivalent in each of these cases.\nA collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from each class during a session.\nYou\u2019re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:\nCreate a slice of the absences array that holds the second half of the days.\nUse the max(by:) method to determine the index of the day with the most absences.\nPrint the result using the index found in step 2 on the original absences array.\nHere\u2019s an implementation of those steps:\nA slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.\nFor example, if you update the last element of the absences array from 0 to 2, the secondHalf slice is unchanged.\nAlthough a sequence can be consumed as it is traversed, a collection is guaranteed to be multipass: Any element can be repeatedly accessed by saving its index. Moreover, a collection\u2019s indices form a finite range of the positions of the collection\u2019s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the contains(_:) method to test whether a collection includes an element.\nIterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the characters view of a string returns the same characters in the same order whether the view\u2019s indices or the view itself is being iterated.\nIf you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:\nThe startIndex and endIndex properties\nA subscript that provides at least read-only access to your type\u2019s elements\nThe index(after:) method for advancing an index into your collection\nTypes that conform to Collection are expected to provide the startIndex and endIndex properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.\nThe performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its count property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its count property is an O(n) operation.\n", "package_name": "swift", "interface_list": [], "Methods": [{"return_value": {"return_name": [""], "return_description": ["The first element of the collection if the collection is not empty; otherwise, nil."], "return_type": ["Self.Element"]}, "class_name": "Collection", "method_description": "Removes and returns the first element of the collection.", "method_name": "popFirst", "params": []}, {"return_value": {"return_name": [""], "return_description": ["The first element of the collection."], "return_type": ["Self.Element"]}, "class_name": "Collection", "method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Collection", "method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "params": [{"param_type": "Int", "param_name": ["k"], "param_description": "The number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection."}]}, {"return_value": {"return_name": [""], "return_description": ["The index value immediately after i."], "return_type": ["Self.Index"]}, "class_name": "Collection", "method_description": "Returns the position immediately after the given index.Required.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["after", "i"], "param_description": "A valid index of the collection. i must be less than endIndex."}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Collection", "method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["i"], "param_description": "A valid index of the collection."}, {"param_type": "Int", "param_name": ["offsetBy", "distance"], "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol."}]}, {"return_value": {"return_name": [""], "return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_type": ["Bool"]}, "class_name": "Collection", "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["i"], "param_description": "A valid index of the collection."}, {"param_type": "Int", "param_name": ["offsetBy", "distance"], "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol."}, {"param_type": "Self.Index", "param_name": ["limitedBy", "limit"], "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect."}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Collection", "method_description": "", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["i"], "param_description": ""}, {"param_type": "BinaryInteger", "param_name": ["offsetBy", "n"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Bool"]}, "class_name": "Collection", "method_description": "", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["i"], "param_description": ""}, {"param_type": "BinaryInteger", "param_name": ["offsetBy", "n"], "param_description": ""}, {"param_type": "Self.Index", "param_name": ["limitedBy", "limit"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["String rethrows -> [String]"]}, "class_name": "Collection", "method_description": "", "method_name": "flatMap", "params": [{"param_type": "(Self.Element", "param_name": ["transform"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Self.Iterator"]}, "class_name": "Collection", "method_description": "Returns an iterator over the elements of the collection.Required. Default implementation provided.", "method_name": "makeIterator", "params": []}, {"return_value": {"return_name": [""], "return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_type": ["[Self.SubSequence]"]}, "class_name": "Collection", "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "method_name": "split", "params": [{"param_type": "Self.Element", "param_name": ["separator"], "param_description": "The element that should be split upon."}, {"param_type": "Int", "param_name": ["maxSplits"], "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max."}, {"param_type": "Bool", "param_name": ["omittingEmptySubsequences"], "param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true."}]}, {"return_value": {"return_name": [""], "return_description": ["A flattened view of the elements of this collection of collections."], "return_type": ["FlattenCollection<Self>"]}, "class_name": "Collection", "method_description": "Returns the elements of this collection of collections, concatenated.", "method_name": "joined", "params": []}, {"return_value": {"return_name": [""], "return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_type": ["Int"]}, "class_name": "Collection", "method_description": "Returns the distance between two indices.Required. Default implementation provided.", "method_name": "distance", "params": [{"param_type": "Self.Index", "param_name": ["from", "start"], "param_description": "A valid index of the collection."}, {"param_type": "Self.Index", "param_name": ["to", "end"], "param_description": "Another valid index of the collection. If end is equal to start, the result is zero."}]}, {"return_value": {"return_name": [""], "return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_type": ["Self.Index"]}, "class_name": "Collection", "method_description": "Returns the first index where the specified value appears in the collection.", "method_name": "firstIndex", "params": [{"param_type": "Self.Element", "param_name": ["of", "element"], "param_description": "An element to search for in the collection."}]}, {"return_value": {"return_name": [""], "return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_type": [""]}, "class_name": "Collection", "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "params": [{"param_type": "(Self.Element", "param_name": ["where", "predicate"], "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match."}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Collection", "method_description": "Replaces the given index with its successor.Required. Default implementation provided.", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["after", "i"], "param_description": "A valid index of the collection. i must be less than endIndex."}]}, {"return_value": {"return_name": [""], "return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_type": ["Self.Index"]}, "class_name": "Collection", "method_description": "Returns an index that is the specified distance from the given index.Required. Default implementation provided.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["i"], "param_description": "A valid index of the collection."}, {"param_type": "Int", "param_name": ["offsetBy", "distance"], "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol."}]}, {"return_value": {"return_name": [""], "return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_type": ["Self.Index"]}, "class_name": "Collection", "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.Required. Default implementation provided.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["i"], "param_description": "A valid index of the collection."}, {"param_type": "Int", "param_name": ["offsetBy", "distance"], "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol."}, {"param_type": "Self.Index", "param_name": ["limitedBy", "limit"], "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect."}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence up to, and including, the end position."], "return_type": ["Self.SubSequence"]}, "class_name": "Collection", "method_description": "Returns a subsequence from the start of the collection through the specified position.Required. Default implementation provided.", "method_name": "prefix", "params": [{"param_type": "Self.Index", "param_name": ["through", "position"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence up to, but not including, the end position."], "return_type": ["Self.SubSequence"]}, "class_name": "Collection", "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.Required. Default implementation provided.", "method_name": "prefix", "params": [{"param_type": "Self.Index", "param_name": ["upTo", "end"], "param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection."}]}, {"return_value": {"return_name": [""], "return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_type": ["Self.Element"]}, "class_name": "Collection", "method_description": "Returns a random element of the collection.", "method_name": "randomElement", "params": []}, {"return_value": {"return_name": [""], "return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_type": ["Self.Element"]}, "class_name": "Collection", "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "params": [{"param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"], "param_description": "The random number generator to use when choosing a random element."}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence starting at the start position."], "return_type": ["Self.SubSequence"]}, "class_name": "Collection", "method_description": "Returns a subsequence from the specified position to the end of the collection.Required. Default implementation provided.", "method_name": "suffix", "params": [{"param_type": "Self.Index", "param_name": ["from", "start"], "param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection."}]}], "class_inherit_list": ["Sequence"], "Vars": [{"var_type": "Self.Index", "var_description": "The position of the first element in a nonempty collection.Required.", "var_name": "startIndex"}, {"var_type": "Self.Index", "var_description": "The collection\u2019s \u201cpast the end\u201d position\u2014that is, the position one greater than the last valid subscript argument.Required.", "var_name": "endIndex"}, {"var_type": "Self.Indices", "var_description": "The indices that are valid for subscripting the collection, in ascending order.Required. Default implementation provided.", "var_name": "indices"}, {"var_type": "LazyCollection<Self>", "var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_name": "lazy"}, {"var_type": "Int", "var_description": "The number of elements in the collection.Required. Default implementation provided.", "var_name": "count"}, {"var_type": "Self.Element", "var_description": "The first element of the collection.Required. Default implementation provided.", "var_name": "first"}, {"var_type": "Bool", "var_description": "A Boolean value indicating whether the collection is empty.Required. Default implementation provided.", "var_name": "isEmpty"}], "subclass_list": ["BidirectionalCollection", "LazyCollectionProtocol", "MutableCollection", "RangeReplaceableCollection"], "class_name": "Collection"}