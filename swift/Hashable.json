{"class_description": "You can use any type that conforms to the Hashable protocol in a set or as a dictionary key. Many types in the standard library conform to Hashable: Strings, integers, floating-point and Boolean values, and even sets are hashable by default. Some other types, such as optionals, arrays and ranges automatically become hashable when their type arguments implement the same.\nYour own custom types can be hashable as well. When you define an enumeration without associated values, it gains Hashable conformance automatically, and you can add Hashable conformance to your other custom types by implementing the hash(into:) method. For structs whose stored properties are all Hashable, and for enum types that have all-Hashable associated values, the compiler is able to provide an implementation of hash(into:) automatically.\nHashing a value means feeding its essential components into a hash function, represented by the Hasher type. Essential components are those that contribute to the type\u2019s implementation of Equatable. Two instances that are equal must feed the same values to Hasher in hash(into:), in the same order.\nTo use your own custom type in a set or as the key type of a dictionary, add Hashable conformance to your type. The Hashable protocol inherits from the Equatable protocol, so you must also satisfy that protocol\u2019s requirements.\nThe compiler automatically synthesizes your custom type\u2019s Hashable and requirements when you declare Hashable conformance in the type\u2019s original declaration and your type meets these criteria:\nFor a struct, all its stored properties must conform to Hashable.\nFor an enum, all its associated values must conform to Hashable. (An enum without associated values has Hashable conformance even without the declaration.)\nTo customize your type\u2019s Hashable conformance, to adopt Hashable in a type that doesn\u2019t meet the criteria listed above, or to extend an existing type to conform to Hashable, implement the hash(into:) method in your custom type.\nIn your hash(into:) implementation, call combine(_:) on the provided Hasher instance with the essential components of your type. To ensure that your type meets the semantic requirements of the Hashable and Equatable protocols, it\u2019s a good idea to also customize your type\u2019s Equatable conformance to match.\nAs an example, consider a GridPoint type that describes a location in a grid of buttons. Here\u2019s the initial declaration of the GridPoint type:\nYou\u2019d like to create a set of the grid points where a user has already tapped. Because the GridPoint type is not hashable yet, it can\u2019t be used in a set. To add Hashable conformance, provide an == operator function and implement the hash(into:) method.\nThe hash(into:) method in this example feeds the grid point\u2019s x and y properties into the provided hasher. These properties are the same ones used to test for equality in the == operator function.\nNow that GridPoint conforms to the Hashable protocol, you can create a set of previously tapped grid points.\n", "package_name": "swift", "interface_list": [], "Methods": [{"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Hashable", "method_description": "Hashes the essential components of this value by feeding them into the given hasher.Required. Default implementation provided.", "method_name": "hash", "params": [{"param_type": "inout Hasher", "param_name": ["into", "hasher"], "param_description": "The hasher to use when combining the components of this instance."}]}], "class_inherit_list": ["Equatable"], "Vars": [{"var_type": "Int", "var_description": "The hash value.Required.", "var_name": "hashValue"}], "subclass_list": ["BinaryInteger", "FloatingPoint", "ReferenceConvertible", "StringProtocol"], "class_name": "Hashable"}