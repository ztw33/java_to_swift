{"class_inherit_list": [], "Vars": [{"var_description": "", "var_type": "Mirror", "var_name": "customMirror"}, {"var_description": "", "var_type": "PlaygroundQuickLook", "var_name": "customPlaygroundQuickLook"}, {"var_description": "A textual representation of the pointer, suitable for debugging.", "var_type": "String", "var_name": "debugDescription"}], "class_name": "UnsafeRawPointer", "interface_list": ["Comparable", "CustomDebugStringConvertible", "CustomPlaygroundQuickLookable", "CustomReflectable", "Equatable", "Hashable", "Strideable"], "subclass_list": [], "class_description": "The UnsafeRawPointer type provides no automated memory management, no type safety, and no alignment guarantees. You are responsible for handling the life cycle of any memory you work with through unsafe pointers, to avoid leaks or undefined behavior.\nMemory that you manually manage can be either untyped or bound to a specific type. You use the UnsafeRawPointer type to access and manage raw bytes in memory, whether or not that memory has been bound to a specific type.\nThe memory referenced by an UnsafeRawPointer instance can be in one of several states. Many pointer operations must only be applied to pointers with memory in a specific state\u2014you must keep track of the state of the memory you are working with and understand the changes to that state that different operations perform. Memory can be untyped and uninitialized, bound to a type and uninitialized, or bound to a type and initialized to a value. Finally, memory that was allocated previously may have been deallocated, leaving existing pointers referencing unallocated memory.\nRaw memory that has just been allocated is in an uninitialized, untyped state. Uninitialized memory must be initialized with values of a type before it can be used with any typed operations.\nTo bind uninitialized memory to a type without initializing it, use the bindMemory(to:count:) method. This method returns a typed pointer for further typed access to the memory.\nMemory that has been bound to a type, whether it is initialized or uninitialized, is typically accessed using typed pointers\u2014instances of UnsafePointer and UnsafeMutablePointer. Initialization, assignment, and deinitialization can be performed using UnsafeMutablePointer methods.\nMemory that has been bound to a type can be rebound to a different type only after it has been deinitialized or if the bound type is a trivial type. Deinitializing typed memory does not unbind that memory\u2019s type. The deinitialized memory can be reinitialized with values of the same type, bound to a new type, or deallocated.\nNote\nA trivial type can be copied bit for bit with no indirection or reference-counting operations. Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enumerations.\nWhen reading from  memory as raw bytes when that memory is bound to a type, you must ensure that you satisfy any alignment requirements.\nPointer arithmetic with raw pointers is performed at the byte level. When you add to or subtract from a raw pointer, the result is a new raw pointer offset by that number of bytes. The following example allocates four bytes of memory and stores 0xFF in all four bytes:\nThe code above stores the value 0xFFFF_FFFF into the four newly allocated bytes, and then loads the first byte as a UInt8 instance and the third and fourth bytes as a UInt16 instance.\nAlways remember to deallocate any memory that you allocate yourself.\nWhen calling a function or method with an UnsafeRawPointer parameter, you can pass an instance of that specific pointer type, pass an instance of a compatible pointer type, or use Swift\u2019s implicit bridging to pass a compatible pointer.\nFor example, the print(address:as:) function in the following code sample takes an UnsafeRawPointer instance as its first parameter:\nAs is typical in Swift, you can call the print(address:as:) function with an UnsafeRawPointer instance. This example passes rawPointer as the initial parameter.\nBecause typed pointers can be implicitly cast to raw pointers when passed as a parameter, you can also call print(address:as:) with any mutable or immutable typed pointer instance.\nAlternatively, you can use Swift\u2019s implicit bridging to pass a pointer to an instance or to the elements of an array. Use inout syntax to implicitly create a pointer to an instance of any type. The following example uses implicit bridging to pass a pointer to value when calling print(address:as:):\nAn immutable pointer to the elements of an array is implicitly created when you pass the array as an argument. This example uses implicit bridging to pass a pointer to the elements of numbers when calling print(address:as:).\nYou can also use inout syntax to pass a mutable pointer to the elements of an array. Because print(address:as:) requires an immutable pointer, although this is syntactically valid, it isn\u2019t necessary.\nImportant\nThe pointer created through implicit bridging of an instance or of an array\u2019s elements is only valid during the execution of the called function. Escaping the pointer to use after the execution of the function is undefined behavior. In particular, do not use implicit bridging when calling an UnsafeRawPointer initializer.\n", "Methods": [{"return_value": {"return_description": ["A pointer offset from this pointer by n bytes."], "return_name": [""], "return_type": ["UnsafeRawPointer"]}, "method_description": "Returns a pointer offset from this pointer by the specified number of bytes.", "method_name": "advanced", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The number of bytes to offset this pointer. n may be positive, negative, or zero.", "param_type": "Int", "param_name": ["by", "n"]}]}, {"return_value": {"return_description": ["A typed pointer to the same memory as this raw pointer."], "return_name": [""], "return_type": ["UnsafePointer<T>"]}, "method_description": "Returns a typed pointer to the memory referenced by this pointer, assuming that the memory is already bound to the specified type.", "method_name": "assumingMemoryBound", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The type T that the memory has already been bound to.", "param_type": "T.Type", "param_name": ["to"]}]}, {"return_value": {"return_description": ["A typed pointer to the newly bound memory. The memory in this region is bound to T, but has not been modified in any other way. The number of bytes in this region is count * MemoryLayout<T>.stride."], "return_name": [""], "return_type": ["UnsafePointer<T>"]}, "method_description": "Binds the memory to the specified type and returns a typed pointer to the bound memory.", "method_name": "bindMemory", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The type T to bind the memory to.", "param_type": "T.Type", "param_name": ["to", "type"]}, {"param_description": "The amount of memory to bind to type T, counted as instances of T.", "param_type": "Int", "param_name": ["capacity", "count"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Deallocates the previously allocated memory block referenced by this pointer.", "method_name": "deallocate", "class_name": "UnsafeRawPointer", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Deallocates memory referenced by the pointer with the specified size and alignment.", "method_name": "deallocate", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "Int", "param_name": ["bytes"]}, {"param_description": "The alignment of the region to be deallocated, in bytes.", "param_type": "Int", "param_name": ["alignedTo"]}]}, {"return_value": {"return_description": ["The distance from this pointer to x, in bytes."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the distance from this pointer to the given pointer.", "method_name": "distance", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The pointer to calculate the distance to.", "param_type": "UnsafeRawPointer", "param_name": ["to", "x"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The hasher to use when combining the components of this instance.", "param_type": "inout Hasher", "param_name": ["into", "hasher"]}]}, {"return_value": {"return_description": ["A new instance of type T, read from the raw bytes at offset. The returned instance is memory-managed and unassociated with the value in the memory referenced by this pointer."], "return_name": [""], "return_type": ["T"]}, "method_description": "Returns a new instance of the given type, constructed from the raw memory at the specified offset.", "method_name": "load", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The offset from this pointer, in bytes. offset must be nonnegative. The default is zero.", "param_type": "Int", "param_name": ["fromByteOffset", "offset"]}, {"param_description": "The type of the instance to create.", "param_type": "T.Type", "param_name": ["as", "type"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "class_name": "UnsafeRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeRawPointer"]}, "method_description": "", "method_name": "+", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeRawPointer"]}, "method_description": "", "method_name": "+", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "Int", "param_name": ["lhs"]}, {"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "", "method_name": "+=", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "inout UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["UnsafeRawPointer"]}, "method_description": "", "method_name": "-", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Int"]}, "method_description": "", "method_name": "-", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "", "method_name": "-=", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "inout UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Int", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeFrom<UnsafeRawPointer>"]}, "method_description": "Returns a partial range extending upward from a lower bound.", "method_name": "...", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The lower bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["minimum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeThrough<UnsafeRawPointer>"]}, "method_description": "Returns a partial range up to, and including, its upper bound.", "method_name": "...", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The upper bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ClosedRange<UnsafeRawPointer>"]}, "method_description": "Returns a closed range that contains both of its bounds.", "method_name": "...", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The lower bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["minimum"]}, {"param_description": "The upper bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ClosedRange<UnsafeRawPointer>"]}, "method_description": "Returns a countable closed range that contains both of its bounds.", "method_name": "...", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["minimum"]}, {"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["PartialRangeUpTo<UnsafeRawPointer>"]}, "method_description": "Returns a partial range up to, but not including, its upper bound.", "method_name": "..", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The upper bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<UnsafeRawPointer>"]}, "method_description": "Returns a half-open range that contains its lower bound but not its upper bound.", "method_name": "..", "class_name": "UnsafeRawPointer", "params": [{"param_description": "The lower bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["minimum"]}, {"param_description": "The upper bound for the range.", "param_type": "UnsafeRawPointer", "param_name": ["maximum"]}]}, {"return_value": {"return_description": ["true if lhs references a memory address earlier than rhs; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the first pointer references an earlier memory location than the second pointer.", "method_name": "", "class_name": "UnsafeRawPointer", "params": [{"param_description": "A pointer.", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "Another pointer.", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is less than that of the second argument.", "method_name": "", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["x"]}, {"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["y"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.", "method_name": "", "class_name": "UnsafeRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": ["true if lhs and rhs reference the same memory address; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two pointers are equal.", "method_name": "==", "class_name": "UnsafeRawPointer", "params": [{"param_description": "A pointer.", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "Another pointer.", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are equal.", "method_name": "==", "class_name": "UnsafeRawPointer", "params": [{"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["x"]}, {"param_description": "", "param_type": "UnsafeRawPointer", "param_name": ["y"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.", "method_name": ">", "class_name": "UnsafeRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}, {"return_value": {"return_description": ["true if lhs is greater than or equal to rhs; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.", "method_name": ">=", "class_name": "UnsafeRawPointer", "params": [{"param_description": "A value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "UnsafeRawPointer", "param_name": ["rhs"]}]}], "package_name": "swift"}