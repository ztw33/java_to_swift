{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": ["URLSessionDataTask"], "return_name": [""], "return_description": ["The new session data task."]}, "method_name": "dataTask", "class_name": "URLSession", "method_description": "Creates a task that retrieves the contents of the specified URL.", "params": [{"param_type": "URL", "param_name": ["with", "url"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionDataTask"], "return_name": [""], "return_description": ["The new session data task."]}, "method_name": "dataTask", "class_name": "URLSession", "method_description": "Creates a task that retrieves the contents of the specified URL, then calls a handler upon completion. ", "params": [{"param_type": "URL", "param_name": ["with", "url"], "param_description": ""}, {"param_type": "@escaping (Data", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionDataTask"], "return_name": [""], "return_description": ["The new session data task."]}, "method_name": "dataTask", "class_name": "URLSession", "method_description": "Creates a task that retrieves the contents of a URL based on the specified URL request object.", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionDataTask"], "return_name": [""], "return_description": ["The new session data task."]}, "method_name": "dataTask", "class_name": "URLSession", "method_description": "Creates a task that retrieves the contents of a URL based on the specified URL request object, and calls a handler upon completion. ", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}, {"param_type": "@escaping (Data", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionDownloadTask"], "return_name": [""], "return_description": ["The new session download task."]}, "method_name": "downloadTask", "class_name": "URLSession", "method_description": "Creates a download task that retrieves the contents of the specified URL and saves the results to a file.", "params": [{"param_type": "URL", "param_name": ["with", "url"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionDownloadTask"], "return_name": [""], "return_description": ["The new session download task."]}, "method_name": "downloadTask", "class_name": "URLSession", "method_description": "Creates a download task that retrieves the contents of the specified URL, saves the results to a file, and calls a handler upon completion. ", "params": [{"param_type": "URL", "param_name": ["with", "url"], "param_description": ""}, {"param_type": "@escaping (URL", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionDownloadTask"], "return_name": [""], "return_description": ["The new session download task."]}, "method_name": "downloadTask", "class_name": "URLSession", "method_description": "Creates a download task that retrieves the contents of a URL based on the specified URL request object and saves the results to a file.", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionDownloadTask"], "return_name": [""], "return_description": ["The new session download task."]}, "method_name": "downloadTask", "class_name": "URLSession", "method_description": "Creates a download task that retrieves the contents of a URL based on the specified URL request object, saves the results to a file, and calls a handler upon completion. ", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}, {"param_type": "@escaping (URL", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionDownloadTask"], "return_name": [""], "return_description": ["The new session download task."]}, "method_name": "downloadTask", "class_name": "URLSession", "method_description": "Creates a download task to resume a previously canceled or failed download.", "params": [{"param_type": "Data", "param_name": ["withResumeData", "resumeData"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionDownloadTask"], "return_name": [""], "return_description": ["The new session download task."]}, "method_name": "downloadTask", "class_name": "URLSession", "method_description": "Creates a download task to resume a previously canceled or failed download and calls a handler upon completion. ", "params": [{"param_type": "Data", "param_name": ["withResumeData", "resumeData"], "param_description": ""}, {"param_type": "@escaping (URL", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionUploadTask"], "return_name": [""], "return_description": ["The new session upload task."]}, "method_name": "uploadTask", "class_name": "URLSession", "method_description": "Creates a task that performs an HTTP request for the specified URL request object and uploads the provided data.", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}, {"param_type": "Data", "param_name": ["from", "bodyData"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionUploadTask"], "return_name": [""], "return_description": ["The new session upload task."]}, "method_name": "uploadTask", "class_name": "URLSession", "method_description": "Creates a task that performs an HTTP request for the specified URL request object, uploads the provided data, and calls a handler upon completion. ", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}, {"param_type": "Data", "param_name": ["from", "bodyData"], "param_description": ""}, {"param_type": "@escaping (Data", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionUploadTask"], "return_name": [""], "return_description": ["The new session upload task."]}, "method_name": "uploadTask", "class_name": "URLSession", "method_description": "Creates a task that performs an HTTP request for uploading the specified file.", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}, {"param_type": "URL", "param_name": ["fromFile", "fileURL"], "param_description": ""}]}, {"return_value": {"return_type": ["Void -> URLSessionUploadTask"], "return_name": [""], "return_description": ["The new session upload task."]}, "method_name": "uploadTask", "class_name": "URLSession", "method_description": "Creates a task that performs an HTTP request for uploading the specified file, then calls a handler upon completion. ", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}, {"param_type": "URL", "param_name": ["fromFile", "fileURL"], "param_description": ""}, {"param_type": "@escaping (Data", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "URLResponse", "param_name": ["URLResponse"], "param_description": ""}, {"param_type": "Error", "param_name": ["Error"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionUploadTask"], "return_name": [""], "return_description": ["The new session upload task."]}, "method_name": "uploadTask", "class_name": "URLSession", "method_description": "Creates a task that performs an HTTP request for uploading data based on the specified URL request.", "params": [{"param_type": "URLRequest", "param_name": ["withStreamedRequest", "request"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionStreamTask"], "return_name": [""], "return_description": ["The new session stream task."]}, "method_name": "streamTask", "class_name": "URLSession", "method_description": "Creates a task that establishes a bidirectional TCP/IP connection to a specified hostname and port.", "params": [{"param_type": "String", "param_name": ["withHostName", "hostname"], "param_description": ""}, {"param_type": "Int", "param_name": ["port"], "param_description": ""}]}, {"return_value": {"return_type": ["URLSessionStreamTask"], "return_name": [""], "return_description": ["The new session stream task."]}, "method_name": "streamTask", "class_name": "URLSession", "method_description": "Creates a task that establishes a bidirectional TCP/IP connection using a specified network service.", "params": [{"param_type": "NetService", "param_name": ["with", "service"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "finishTasksAndInvalidate", "class_name": "URLSession", "method_description": "Invalidates the session, allowing any outstanding tasks to finish.", "params": []}, {"return_value": {"return_type": ["Void"], "return_name": [""], "return_description": []}, "method_name": "flush", "class_name": "URLSession", "method_description": "Flushes cookies and credentials to disk, clears transient caches, and ensures that future requests occur on a new TCP connection.", "params": [{"param_type": "@escaping (", "param_name": ["completionHandler"], "param_description": ""}]}, {"return_value": {"return_type": ["Void"], "return_name": [""], "return_description": []}, "method_name": "getTasksWithCompletionHandler", "class_name": "URLSession", "method_description": "Asynchronously calls a completion callback with all data, upload, and download tasks in a session.", "params": [{"param_type": "@escaping ([URLSessionDataTask]", "param_name": ["completionHandler"], "param_description": ""}, {"param_type": "[URLSessionUploadTask]", "param_name": ["[URLSessionUploadTask]"], "param_description": ""}, {"param_type": "[URLSessionDownloadTask]", "param_name": ["[URLSessionDownloadTask]"], "param_description": ""}]}, {"return_value": {"return_type": ["Void"], "return_name": [""], "return_description": []}, "method_name": "getAllTasks", "class_name": "URLSession", "method_description": "Asynchronously calls a completion callback with all tasks in a session", "params": [{"param_type": "@escaping ([URLSessionTask]", "param_name": ["completionHandler"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "invalidateAndCancel", "class_name": "URLSession", "method_description": "Cancels all outstanding tasks and then invalidates the session.", "params": []}, {"return_value": {"return_type": ["Void"], "return_name": [""], "return_description": []}, "method_name": "reset", "class_name": "URLSession", "method_description": "Empties all cookies, caches and credential stores, removes disk files, flushes in-progress downloads to disk, and ensures that future requests occur on a new socket.", "params": [{"param_type": "@escaping (", "param_name": ["completionHandler"], "param_description": ""}]}], "Vars": [{"var_type": "URLSession", "var_description": "The shared singleton session object.", "var_name": "shared"}, {"var_type": "URLSessionConfiguration", "var_description": "A copy of the configuration object for this session.", "var_name": "configuration"}, {"var_type": "URLSessionDelegate", "var_description": "The delegate assigned when this object was created.", "var_name": "delegate"}, {"var_type": "OperationQueue", "var_description": "The operation queue provided when this object was created.", "var_name": "delegateQueue"}, {"var_type": "String", "var_description": "An app-defined descriptive label for the session.", "var_name": "sessionDescription"}, {"var_type": "String", "var_description": "A key in the error dictionary that provides resume data.", "var_name": "NSURLSessionDownloadTaskResumeData"}, {"var_type": "String", "var_description": "An NSNumber value indicating why a background task was cancelled. For a list of possible values, see NSURLSession-Specific NSError userInfo Dictionary Keys.", "var_name": "NSURLErrorBackgroundTaskCancelledReasonKey"}, {"var_type": "Int", "var_description": "The operation was canceled because the user forced the app to quit.", "var_name": "NSURLErrorCancelledReasonUserForceQuitApplication"}, {"var_type": "Int", "var_description": "The operation was canceled because background updates are disabled. See Background Execution for more information.", "var_name": "NSURLErrorCancelledReasonBackgroundUpdatesDisabled"}, {"var_type": "Int", "var_description": "The operation was canceled due to insufficient system resources.", "var_name": "NSURLErrorCancelledReasonInsufficientSystemResources"}], "subclass_list": [], "class_description": "The URLSession class and related classes provide an API for downloading content. This API provides a rich set of delegate methods for supporting authentication and gives your app the ability to perform background downloads when your app isn\u2019t running or, in iOS, while your app is suspended.\nImportant\nThe URLSession API involves many different classes working together in a fairly complex way that may not be obvious if you read the reference documentation by itself. Before using this API, you should read the overview in the URL Loading System topic. The articles in the First Steps section offer examples of performing common tasks with URLSession.\nWith the URLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you\u2019re  creating a web browser, your app might create one session per tab or window, or one session for interactive use and another for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects, if necessary).\nThe tasks within a given URL session share a common session configuration object, which defines connection behavior, such as the maximum number of simultaneous connections to make to a single host, whether to allow connections over a cellular network, and so on.\nURLSession has a singleton shared session (which has no configuration object) for basic requests. It\u2019s not as customizable as sessions you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. For other kinds of sessions, you instantiate a URLSession with one of three kinds of configurations:\nA default session behaves much like the shared session, but allows more configuration, and allows you to obtain data incrementally with a delegate.\nEphemeral sessions are similar to shared sessions, but don\u2019t write caches, cookies, or credentials to disk.\nBackground sessions let you perform uploads and downloads of content in the background while your app isn't running.\nSee Creating a Session Configuration Object in the URLSessionConfiguration class for details on creating each type of configuration.\nWithin a session, you create tasks that optionally upload data to a server and then retrieve data from the server either as a file on disk or as one or more NSData objects in memory. The URLSession API provides three types of tasks:\nData tasks send and receive data using NSData objects. Data tasks are intended for short, often interactive requests to a server.\nUpload tasks are similar to data tasks, but they also send data (often in the form of a file), and support background uploads while the app isn\u2019t running.\nDownload tasks retrieve data in the form of a file, and support background downloads and uploads while the app isn\u2019t running.\n\nThe tasks in a session also share a common delegate that lets you provide and obtain information when various events occur\u2014when authentication fails, when data arrives from the server, when data is ready to be cached, and so on.  Using a URL Session has a step-by-step list of events that occur when a session is performing a task, and which delegate methods are called as a result. \nOn the other hand, if you don\u2019t need any of the features provided by a delegate, you can use this API without providing one by passing nil when you create a session. \nImportant\nThe session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you don\u2019t invalidate the session, your app leaks memory until it exits.\n\nLike most networking APIs, the URLSession API is highly asynchronous. It returns data to your app in one of two ways, depending on the methods you call:\nBy calling a completion handler block when a transfer finishes successfully or with an error.\nBy calling methods on the session\u2019s delegate as data is received and when the transfer is complete.\nIn addition to delivering this information to delegates, the URLSession API provides status and progress properties that you can query if you need to make programmatic decisions based on the current state of the task (with the caveat that its state can change at any time). \nURL sessions also support canceling, restarting or resuming, and suspending tasks, and provide the ability to resume suspended, canceled, or failed downloads where they left off.\n\nThe URLSession class natively supports the data, file, ftp, http, and https URL schemes, with transparent support for proxy servers and SOCKS gateways, as configured in the user\u2019s system preferences.  \nURLSession supports the HTTP/1.1, SPDY, and HTTP/2 protocols. HTTP/2 support is described by RFC 7540, and requires a server supporting either ALPN or NPN for protocol negotiation.\nYou can also add support for your own custom networking protocols and URL schemes (for your app\u2019s private use) by subclassing URLProtocol.\nStarting in iOS 9.0 and OS X 10.11, a new security feature called App Transport Security (ATS) is enabled by default for all HTTP connections made with URLSession. ATS requires that HTTP connections use HTTPS (RFC 2818).\nFor more information, see NSAppTransportSecurity in the Information Property List Key Reference.\nTo make a request using the URLSession class:\nCreate a session configuration. For background sessions, this configuration must contain a unique identifier. Store that identifier, and use it to reassociate with the session if your app crashes or is terminated or suspended.\nCreate a session, specifying a configuration object and, optionally, a delegate.\nCreate task objects within a session that each represent a resource request. These task objects are subclasses of URLSessionTask\u2014URLSessionDataTask, URLSessionUploadTask, or URLSessionDownloadTask, depending on the behavior you\u2019re trying to achieve. Each task starts in a suspended state. After your app calls resume() on the task, it begins downloading the specified resource.\nAfter you start a task, the session calls methods on its delegate, as follows:\nIf the initial handshake with the server requires a connection-level challenge (such as an SSL client certificate), URLSession calls either the urlSession(_:task:didReceive:completionHandler:) or urlSession(_:didReceive:completionHandler:) delegate method.\nIf the task\u2019s data is provided from a stream, the URLSession object calls the delegate\u2019s urlSession(_:task:needNewBodyStream:) delegate method to obtain an instance of InputStream that provides the body data for the new request.\nDuring the initial upload of body content to the server (if applicable), the delegate periodically receives urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:) callbacks that report the progress of the upload.\nThe server sends a response.\nIf the response indicates that authentication is required, the session calls its delegate\u2019s urlSession(_:task:didReceive:completionHandler:) method. Go back to step 2.\nIf the response is an HTTP redirect response, the URLSession object calls the delegate\u2019s urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:) method. That delegate method calls the provided completion handler with either the provided NSURLRequest object (to follow the redirect), a new NSURLRequest object (to redirect to a different URL), or nil (to treat the redirect\u2019s response body as a valid response and return it as the result).\nIf you decide to follow the redirect, go back to step 2.\nIf the delegate doesn\u2019t implement this method, the redirect is followed up to the maximum number of redirects.\nFor a download (or redownload) task created by calling downloadTask(withResumeData:) or downloadTask(withResumeData:completionHandler:), URLSession calls the delegate\u2019s urlSession(_:downloadTask:didResumeAtOffset:expectedTotalBytes:) method with the new task object.\nFor a data task, the URLSession object calls the delegate\u2019s urlSession(_:dataTask:didReceive:completionHandler:) method. Decide whether to convert the data task into a download task, and then call the completion handler to convert, continue, or cancel the task. If your app chooses to convert the data task to a download task, URLSession calls the delegate\u2019s urlSession(_:dataTask:didBecome:) method with the new download task as a parameter. After this call, the delegate receives no further callbacks from the data task, and begins receiving callbacks from the download task.\nDuring the transfer from the server, the delegate periodically receives a task-level callback to report the progress of the transfer. For a data task, the session calls the delegate\u2019s urlSession(_:dataTask:didReceive:)method with the actual pieces of data as they\u2019re received. For a download task, the session calls the delegate\u2019s urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:) method with the number of bytes successfully written to disk. If the user tells your app to pause the download, cancel the task by calling the cancel(byProducingResumeData:) method. Later, if the user asks your app to resume the download, pass the returned resume data to either the downloadTask(withResumeData:) or downloadTask(withResumeData:completionHandler:) method to create a new download task that continues the download. (Go to step 1.)\nFor a data task, the URLSession object may call the delegate\u2019s urlSession(_:dataTask:willCacheResponse:completionHandler:) method. Your app should then decide whether to allow caching. If you don\u2019t implement this method, the default behavior is to use the caching policy specified in the session\u2019s configuration object.\nIf the response is multipart encoded, the session may call the delegate\u2019s didReceiveResponse method again, followed by zero or more additional didReceiveData calls. If this happens, go to step 8 (handling the didReceiveResponse call).\nIf a download task completes successfully, then the URLSession object calls the task\u2019s urlSession(_:downloadTask:didFinishDownloadingTo:) method with the location of a temporary file. Your app must either read the response data from this file or move it to a permanent location before this delegate method returns.\nWhen any task completes, the URLSession object calls the delegate\u2019s urlSession(_:task:didCompleteWithError:) method with either an error object or nil (if the task completed successfully). If the download task can be resumed, the NSError object\u2019s userInfo dictionary contains a value for the NSURLSessionDownloadTaskResumeData key. Your app should pass this value to call downloadTask(withResumeData:) or downloadTask(withResumeData:completionHandler:) to create a new download task that continues the existing download. If the task can\u2019t be resumed, your app should create a new download task and restart the transaction from the beginning. In either case, if the transfer failed for any reason other than a server error, go to step 3 (creating and resuming task objects).\nIf you no longer need a session, you can invalidate it by calling either invalidateAndCancel() (to cancel outstanding tasks) or finishTasksAndInvalidate() (to allow outstanding tasks to finish before invalidating the object). If you don\u2019t invalidate the session, it automatically goes away when your app is terminated (unless it\u2019s a background session with active tasks). After invalidating the session, when all outstanding tasks have been canceled or have finished, the session calls the delegate\u2019s urlSession(_:didBecomeInvalidWithError:) method. When that delegate method returns, the session disposes of its strong reference to the delegate.\nIf your app cancels an in-progress download, the URLSession object calls the delegate\u2019s urlSession(_:task:didCompleteWithError:) method as though an error occurred.\nSession and task objects conform to the NSCopying protocol as follows:\nWhen your app copies a session or task object, you get the same object back.\nWhen your app copies a configuration object, you get a new copy that you can independently modify.\nThe URL session API itself is fully thread-safe. You can freely create sessions and tasks in any thread context, and when your delegate methods call the provided completion handlers, the work is automatically scheduled on the correct delegate queue.\nWarning\nYour urlSessionDidFinishEvents(forBackgroundURLSession:) session delegate method may be called on a secondary thread. However, in iOS, your implementation of that method may need to call a completion handler provided to you in your application(_:handleEventsForBackgroundURLSession:completionHandler:) app delegate method. You must call that completion handler on the main thread.\n", "class_name": "URLSession"}