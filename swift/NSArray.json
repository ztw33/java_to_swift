{"class_inherit_list": ["NSObject"], "Vars": [{"var_description": "The number of objects in the array.", "var_type": "Int", "var_name": "count"}, {"var_description": "The first object in the array.", "var_type": "Any", "var_name": "firstObject"}, {"var_description": "The last object in the array.", "var_type": "Any", "var_name": "lastObject"}, {"var_description": "Analyzes the array and returns a \u201chint\u201d that speeds the sorting of the array when the hint is supplied to sortedArray(_:context:hint:).", "var_type": "Data", "var_name": "sortedArrayHint"}, {"var_description": "A string that represents the contents of the array, formatted as a property list.", "var_type": "String", "var_name": "description"}, {"var_description": "", "var_type": "Mirror", "var_name": "customMirror"}], "class_name": "NSArray", "interface_list": ["CKRecordValueProtocol", "CustomReflectable", "CVarArg", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "NSCopying", "NSFastEnumeration", "NSMutableCopying", "NSSecureCoding", "Sequence"], "subclass_list": [], "class_description": "NSArray and its subclass NSMutableArray manage ordered collections of objects called arrays. NSArray creates static arrays, and NSMutableArray creates dynamic arrays. You can use arrays when you need an ordered collection of objects.\nNSArray is \u201ctoll-free bridged\u201d with its Core Foundation counterpart, CFArray. See Toll-Free Bridging for more information on toll-free bridging.\nIn addition to the provided initializers, such as initWithObjects:, you can create an NSArray object using an array literal.\nIn Objective-C, the compiler generates code that makes an underlying call to the init(objects:count:) method.\nYou should not terminate the list of objects with nil when using this literal syntax, and in fact nil is an invalid value. For more information about object literals in Objective-C, see Working with Objects in Programming with Objective-C.\nIn Swift, the NSArray class conforms to the ArrayLiteralConvertible protocol, which allows it to be initialized with array literals. For more information about object literals in Swift, see Literal Expression in The Swift Programming Language (Swift 4.1).\nIn addition to the provided instance methods, such as object(at:), you can access NSArray values by their indexes using subscripting.\nThere is typically little reason to subclass NSArray. The class does well what it is designed to do\u2014maintain an ordered collection of objects. But there are situations where a custom NSArray object might come in handy. Here are a few possibilities:\nChanging how NSArray stores the elements of its collection. You might do this for performance reasons or for better compatibility with legacy code.\nAcquiring more information about what is happening to the collection (for example, statistics gathering).\nAny subclass of NSArray must override the primitive instance methods count and object(at:). These methods must operate on the backing store that you provide for the elements of the collection. For this backing store you can use a static array, a standard NSArray object, or some other data type or mechanism. You may also choose to override, partially or fully, any other NSArray method for which you want to provide an alternative implementation.\nYou might want to implement an initializer for your subclass that is suited to the backing store that the subclass is managing. If you do, your initializer must invoke one of the designated initializers of the NSArray class, either init() or init(objects:count:). The NSArray class adopts the NSCopying, NSMutableCopying, and NSCoding protocols; custom subclasses of NSArray should override the methods in these protocols as necessary.\nRemember that NSArray is the public interface for a class cluster and what this entails for your subclass. You must provide the storage for your subclass and implement the primitive methods that directly act on that storage.\nBefore making a custom subclass of NSArray, investigate NSPointerArray and the corresponding Core Foundation type, CFArray. Because NSArray and CFArray are \u201ctoll-free bridged,\u201d you can substitute a CFArray object for a NSArray object in your code (with appropriate casting). Although they are corresponding types, CFArray and NSArray do not have identical interfaces or implementations, and you can sometimes do things with CFArray that you cannot easily do with NSArray. For example, CFArray provides a set of callbacks, some of which are for implementing custom retain-release behavior. If you specify NULL implementations for these callbacks, you can easily get a non-retaining array.\nIf the behavior you want to add supplements that of the existing class, you could write a category on NSArray. Keep in mind, however, that this category will be in effect for all instances of NSArray that you use, and this might have unintended consequences. Alternatively, you could use composition to achieve the desired behavior.\n", "Methods": [{"return_value": {"return_description": ["true if anObject is present in the array, otherwise false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value that indicates whether a given object is present in the array.", "method_name": "contains", "class_name": "NSArray", "params": [{"param_description": "An object to look for in the array.", "param_type": "Any", "param_name": ["anObject"]}]}, {"return_value": {"return_description": ["The object located at index."], "return_name": [""], "return_type": ["Any"]}, "method_description": "Returns the object located at the specified index.", "method_name": "object", "class_name": "NSArray", "params": [{"param_description": "An index within the bounds of the array.", "param_type": "Int", "param_name": ["at", "index"]}]}, {"return_value": {"return_description": ["An array containing the objects in the array at the indexes specified by indexes."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns an array containing the objects in the array at the indexes specified by a given index set.", "method_name": "objects", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "IndexSet", "param_name": ["at", "indexes"]}]}, {"return_value": {"return_description": ["An enumerator object that lets you access each object in the array, in order, from the element at the lowest index upwards."], "return_name": [""], "return_type": ["NSEnumerator"]}, "method_description": "Returns an enumerator object that lets you access each object in the array.", "method_name": "objectEnumerator", "class_name": "NSArray", "params": []}, {"return_value": {"return_description": ["An enumerator object that lets you access each object in the array, in order, from the element at the highest index down to the element at index 0."], "return_name": [""], "return_type": ["NSEnumerator"]}, "method_description": "Returns an enumerator object that lets you access each object in the array, in reverse order.", "method_name": "reverseObjectEnumerator", "class_name": "NSArray", "params": []}, {"return_value": {"return_description": ["The lowest index whose corresponding array value is equal to anObject. If none of the objects in the array is equal to anObject, returns NSNotFound."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the lowest index whose corresponding array value is equal to a given object.", "method_name": "index", "class_name": "NSArray", "params": [{"param_description": "An object.", "param_type": "Any", "param_name": ["of", "anObject"]}]}, {"return_value": {"return_description": ["The lowest index within range whose corresponding array value is equal to anObject. If none of the objects within range is equal to anObject, returns NSNotFound."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the lowest index within a specified range whose corresponding array value is equal to a given object .", "method_name": "index", "class_name": "NSArray", "params": [{"param_description": "An object.", "param_type": "Any", "param_name": ["of", "anObject"]}, {"param_description": "The range of indexes in the array within which to search for anObject.", "param_type": "NSRange", "param_name": ["in", "range"]}]}, {"return_value": {"return_description": ["The lowest index whose corresponding array value is identical to anObject. If none of the objects in the array is identical to anObject, returns NSNotFound."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the lowest index whose corresponding array value is identical to a given object.", "method_name": "indexOfObjectIdentical", "class_name": "NSArray", "params": [{"param_description": "An object.", "param_type": "Any", "param_name": ["to", "anObject"]}]}, {"return_value": {"return_description": ["The lowest index within range whose corresponding array value is identical to anObject. If none of the objects within range is identical to anObject, returns NSNotFound."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the lowest index within a specified range whose corresponding array value is equal to a given object .", "method_name": "indexOfObjectIdentical", "class_name": "NSArray", "params": [{"param_description": "An object.", "param_type": "Any", "param_name": ["to", "anObject"]}, {"param_description": "The range of indexes in the array within which to search for anObject.", "param_type": "NSRange", "param_name": ["in", "range"]}]}, {"return_value": {"return_description": ["The lowest index whose corresponding value in the array passes the test specified by predicate. If no objects in the array pass the test, returns NSNotFound."], "return_name": [""], "return_type": ["Bool -> Int"]}, "method_description": "Returns the index of the first object in the array that passes a test in a given block.", "method_name": "indexOfObject", "class_name": "NSArray", "params": [{"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.The block returns a Boolean value that indicates whether obj passed the test. Returning true will stop further processing of the array.", "param_type": "(Any", "param_name": ["passingTest", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["The index whose corresponding value in the array passes the test specified by predicate and opts. If the opts bit mask specifies reverse order, then the last item that matches is returned. Otherwise, the index of the first matching object is returned. If no objects in the array pass the test, returns NSNotFound."], "return_name": [""], "return_type": ["Bool -> Int"]}, "method_description": "Returns the index of an object in the array that passes a test in a given block for a given set of enumeration options.", "method_name": "indexOfObject", "class_name": "NSArray", "params": [{"param_description": "A bit mask that specifies the options for the enumeration (whether it should be performed concurrently and whether it should be performed in reverse order).", "param_type": "NSEnumerationOptions", "param_name": ["options", "opts"]}, {"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. When the NSEnumerationConcurrent enumeration option is specified, enumeration stops after all of the currently running blocks finish. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.The block returns a Boolean value that indicates whether obj passed the test.", "param_type": "(Any", "param_name": ["passingTest", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["The lowest index whose corresponding value in the array passes the test specified by predicate. If no objects in the array pass the test, returns NSNotFound."], "return_name": [""], "return_type": ["Bool -> Int"]}, "method_description": "Returns the index, from a given set of indexes, of the first object in the array that passes a test in a given block for a given set of enumeration options.", "method_name": "indexOfObject", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "IndexSet", "param_name": ["at", "s"]}, {"param_description": "A bit mask that specifies the options for the enumeration (whether it should be performed concurrently and whether it should be performed in reverse order).", "param_type": "NSEnumerationOptions", "param_name": ["options", "opts"]}, {"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. When the NSEnumerationConcurrent enumeration option is specified, enumeration stops after all of the currently running blocks finish. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.The block returns a Boolean value that indicates whether obj passed the test.", "param_type": "(Any", "param_name": ["passingTest", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["The indexes whose corresponding values in the array pass the test specified by predicate. If no objects in the array pass the test, returns an empty index set."], "return_name": [""], "return_type": ["Bool -> IndexSet"]}, "method_description": "Returns the indexes of objects in the array that pass a test in a given block.", "method_name": "indexesOfObjects", "class_name": "NSArray", "params": [{"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.The block returns a Boolean value that indicates whether obj passed the test.", "param_type": "(Any", "param_name": ["passingTest", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["The indexes whose corresponding values in the array pass the test specified by predicate. If no objects in the array pass the test, returns an empty index set."], "return_name": [""], "return_type": ["Bool -> IndexSet"]}, "method_description": "Returns the indexes of objects in the array that pass a test in a given block for a given set of enumeration options.", "method_name": "indexesOfObjects", "class_name": "NSArray", "params": [{"param_description": "A bit mask that specifies the options for the enumeration (whether it should be performed concurrently and whether it should be performed in reverse order).", "param_type": "NSEnumerationOptions", "param_name": ["options", "opts"]}, {"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. When the NSEnumerationConcurrent enumeration option is specified, enumeration stops after all of the currently running blocks finish. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.The block returns a Boolean value that indicates whether obj passed the test.", "param_type": "(Any", "param_name": ["passingTest", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["The indexes whose corresponding values in the array pass the test specified by predicate. If no objects in the array pass the test, returns an empty index set."], "return_name": [""], "return_type": ["Bool -> IndexSet"]}, "method_description": "Returns the indexes, from a given set of indexes, of objects in the array that pass a test in a given block for a given set of enumeration options.", "method_name": "indexesOfObjects", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "IndexSet", "param_name": ["at", "s"]}, {"param_description": "A bit mask that specifies the options for the enumeration (whether it should be performed concurrently and whether it should be performed in reverse order).", "param_type": "NSEnumerationOptions", "param_name": ["options", "opts"]}, {"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. When the NSEnumerationConcurrent enumeration option is specified, enumeration stops after all of the currently running blocks finish. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.The block returns a Boolean value that indicates whether obj passed the test.", "param_type": "(Any", "param_name": ["passingTest", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["If the insertionIndex option is not specified:"], "return_name": [""], "return_type": ["ComparisonResult -> Int"]}, "method_description": "Returns the index, within a specified range, of an object compared with elements in the array using a given NSComparator block.", "method_name": "index", "class_name": "NSArray", "params": [{"param_description": "An object for which to search in the array.If this value is nil, throws an invalidArgumentException.", "param_type": "Any", "param_name": ["of", "obj"]}, {"param_description": "The range within the array to search for obj.If r exceeds the bounds of the array (if the location plus length of the range is greater than the count of the array), throws an rangeException.", "param_type": "NSRange", "param_name": ["inSortedRange", "r"]}, {"param_description": "Options for the search. For possible values, see NSBinarySearchingOptions.If you specify both firstEqual and lastEqual, throws an NSInvalidArgumentException.", "param_type": "NSBinarySearchingOptions", "param_name": ["options", "opts"]}, {"param_description": "A comparator block used to compare the object obj with elements in the array.If this value is NULL, throws an invalidArgumentException.", "param_type": "(Any", "param_name": ["usingComparator", "cmp"]}, {"param_description": "", "param_type": "Any", "param_name": ["Any"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Void"]}, "method_description": "Executes a given closure using each object in the array, starting with the first object and continuing through the array to the last object.", "method_name": "enumerateObjects", "class_name": "NSArray", "params": [{"param_description": "A closure to execute for each object in the array. The closure takes three arguments:The object.The index of the object in the array.A reference to a Boolean value, which the closure can set to true in order to stop further enumeration of the array. If a closure stops further enumeration, that closure continues to run until it\u2019s finished.", "param_type": "(Any", "param_name": ["block"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Void"]}, "method_description": "Executes a given closure using each object in the array with the specified options.", "method_name": "enumerateObjects", "class_name": "NSArray", "params": [{"param_description": "The options for the enumeration. For possible values, see NSEnumerationOptions.", "param_type": "NSEnumerationOptions", "param_name": ["options", "opts"]}, {"param_description": "A closure to execute for each object in the array. The closure takes three arguments:The object.The index of the object in the array.A reference to a Boolean value, which the closure can set to true in order to stop further enumeration of the array. If a closure stops further enumeration, that closure continues to run until it\u2019s finished. When the concurrent enumeration option is specified, enumeration stops after all of the currently running closures finish.", "param_type": "(Any", "param_name": ["using", "block"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Void"]}, "method_description": "Executes a given block using the objects in the array at the specified indexes.", "method_name": "enumerateObjects", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "IndexSet", "param_name": ["at", "s"]}, {"param_description": "A bit mask that specifies the options for the enumeration (whether it should be performed concurrently and whether it should be performed in reverse order).", "param_type": "NSEnumerationOptions", "param_name": ["options", "opts"]}, {"param_description": "The block to apply to elements in the array.The block takes three arguments:objThe element in the array.idxThe index of the element in the array.stopA reference to a Boolean value. The block can set the value to true to stop further enumeration of the array. If a block stops further enumeration, that block continues to run until it\u2019s finished. When the NSEnumerationConcurrent enumeration option is specified, enumeration stops after all of the currently running blocks finish. The stop argument is an out-only argument. You should only ever set this Boolean to true within the block.", "param_type": "(Any", "param_name": ["using", "block"]}, {"param_description": "", "param_type": "Int", "param_name": ["Int"]}, {"param_description": "", "param_type": "UnsafeMutablePointer<ObjCBool>", "param_name": ["UnsafeMutablePointer<ObjCBool>"]}]}, {"return_value": {"return_description": ["Returns the first object contained in the receiving array that\u2019s equal to an object in otherArray. If no such object is found, returns nil. "], "return_name": [""], "return_type": ["Any"]}, "method_description": "Returns the first object contained in the receiving array that\u2019s equal to an object in another given array.", "method_name": "firstObjectCommon", "class_name": "NSArray", "params": [{"param_description": "An array.", "param_type": "[Any]", "param_name": ["with", "otherArray"]}]}, {"return_value": {"return_description": ["true if the contents of otherArray are equal to the contents of the receiving array, otherwise false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Compares the receiving array to another array.", "method_name": "isEqual", "class_name": "NSArray", "params": [{"param_description": "An array.", "param_type": "[Any]", "param_name": ["to", "otherArray"]}]}, {"return_value": {"return_description": ["A new array that is a copy of the receiving array with anObject added to the end."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns a new array that is a copy of the receiving array with a given object added to the end.", "method_name": "adding", "class_name": "NSArray", "params": [{"param_description": "An object.", "param_type": "Any", "param_name": ["anObject"]}]}, {"return_value": {"return_description": ["A new array that is a copy of the receiving array with the objects contained in otherArray added to the end."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns a new array that is a copy of the receiving array with the objects contained in another array added to the end.", "method_name": "addingObjects", "class_name": "NSArray", "params": [{"param_description": "An array.", "param_type": "[Any]", "param_name": ["from", "otherArray"]}]}, {"return_value": {"return_description": ["A new array containing the objects in the receiving array for which predicate returns true."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Evaluates a given predicate against each object in the receiving array and returns a new array containing the objects for which the predicate returns true.", "method_name": "filtered", "class_name": "NSArray", "params": [{"param_description": "The predicate against which to evaluate the receiving array\u2019s elements.", "param_type": "NSPredicate", "param_name": ["using", "predicate"]}]}, {"return_value": {"return_description": ["A new array containing the receiving array\u2019s elements that fall within the limits specified by range."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns a new array containing the receiving array\u2019s elements that fall within the limits specified by a given range.", "method_name": "subarray", "class_name": "NSArray", "params": [{"param_description": "A range within the receiving array\u2019s range of elements.", "param_type": "NSRange", "param_name": ["with", "range"]}]}, {"return_value": {"return_description": [], "return_name": ["", ["context"]], "return_type": ["Int", "UnsafeMutableRawPointer -> [Any]"]}, "method_description": "Returns a new array that lists the receiving array\u2019s elements in ascending order as defined by the comparison function comparator.", "method_name": "sortedArray", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "(Any", "param_name": ["comparator"]}, {"param_description": "", "param_type": "Any", "param_name": ["Any"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["UnsafeMutableRawPointer"]}]}, {"return_value": {"return_description": [], "return_name": ["", ["context"], ["hint"]], "return_type": ["Int", "UnsafeMutableRawPointer", "Data -> [Any]"]}, "method_description": "Returns a new array that lists the receiving array\u2019s elements in ascending order as defined by the comparison function comparator.", "method_name": "sortedArray", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "(Any", "param_name": ["comparator"]}, {"param_description": "", "param_type": "Any", "param_name": ["Any"]}, {"param_description": "", "param_type": "UnsafeMutableRawPointer", "param_name": ["UnsafeMutableRawPointer"]}]}, {"return_value": {"return_description": ["A copy of the receiving array sorted as specified by sortDescriptors."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns a copy of the receiving array sorted as specified by a given array of sort descriptors.", "method_name": "sortedArray", "class_name": "NSArray", "params": [{"param_description": "An array of NSSortDescriptor objects.", "param_type": "[NSSortDescriptor]", "param_name": ["using", "sortDescriptors"]}]}, {"return_value": {"return_description": ["An array that lists the receiving array\u2019s elements in ascending order, as determined by the comparison method specified by the selector comparator."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns an array that lists the receiving array\u2019s elements in ascending order, as determined by the comparison method specified by a given selector.", "method_name": "sortedArray", "class_name": "NSArray", "params": [{"param_description": "A selector that identifies the method to use to compare two elements at a time. The method should return NSOrderedAscending if the receiving array is smaller than the argument, NSOrderedDescending if the receiving array is larger than the argument, and NSOrderedSame if they are equal.", "param_type": "Selector", "param_name": ["using", "comparator"]}]}, {"return_value": {"return_description": ["An array that lists the receiving array\u2019s elements in ascending order, as determined by the comparison method specified cmptr."], "return_name": [""], "return_type": ["ComparisonResult -> [Any]"]}, "method_description": "Returns an array that lists the receiving array\u2019s elements in ascending order, as determined by the comparison method specified by a given NSComparator block.", "method_name": "sortedArray", "class_name": "NSArray", "params": [{"param_description": "A comparator block.", "param_type": "(Any", "param_name": ["comparator", "cmptr"]}, {"param_description": "", "param_type": "Any", "param_name": ["Any"]}]}, {"return_value": {"return_description": ["An array that lists the receiving array\u2019s elements in ascending order, as determined by the comparison method specified cmptr."], "return_name": [""], "return_type": ["ComparisonResult -> [Any]"]}, "method_description": "Returns an array that lists the receiving array\u2019s elements in ascending order, as determined by the comparison method specified by a given NSComparator block.", "method_name": "sortedArray", "class_name": "NSArray", "params": [{"param_description": "A bit mask that specifies the options for the sort (whether it should be performed concurrently and whether it should be performed stably).", "param_type": "NSSortOptions", "param_name": ["options", "opts"]}, {"param_description": "A comparator block.", "param_type": "(Any", "param_name": ["usingComparator", "cmptr"]}, {"param_description": "", "param_type": "Any", "param_name": ["Any"]}]}, {"return_value": {"return_description": ["An NSString object that is the result of interposing separator between the elements of the array. If the array has no elements, returns an NSString object representing an empty string."], "return_name": [""], "return_type": ["String"]}, "method_description": "Constructs and returns an NSString object that is the result of interposing a given separator between the elements of the array.", "method_name": "componentsJoined", "class_name": "NSArray", "params": [{"param_description": "The string to interpose between the elements of the array.", "param_type": "String", "param_name": ["by", "separator"]}]}, {"return_value": {"return_description": ["A string that represents the contents of the array, formatted as a property list."], "return_name": [""], "return_type": ["String"]}, "method_description": "Returns a string that represents the contents of the array, formatted as a property list.", "method_name": "description", "class_name": "NSArray", "params": [{"param_description": "An NSLocale object or an NSDictionary object that specifies options used for formatting each of the array\u2019s elements (where recognized). Specify nil if you don\u2019t want the elements formatted.", "param_type": "Any", "param_name": ["withLocale", "locale"]}]}, {"return_value": {"return_description": ["A string that represents the contents of the array, formatted as a property list."], "return_name": [""], "return_type": ["String"]}, "method_description": "Returns a string that represents the contents of the array, formatted as a property list.", "method_name": "description", "class_name": "NSArray", "params": [{"param_description": "An NSLocale object or an NSDictionary object that specifies options used for formatting each of the array\u2019s elements (where recognized). Specify nil if you don\u2019t want the elements formatted.", "param_type": "Any", "param_name": ["withLocale", "locale"]}, {"param_description": "A level of indent, to make the output more readable: set level to 0 to use four spaces to indent, or 1 to indent the output with a tab character.", "param_type": "Int", "param_name": ["indent", "level"]}]}, {"return_value": {"return_description": ["true if the file is written successfully, otherwise false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Writes the contents of the array to a file at a given path.", "method_name": "write", "class_name": "NSArray", "params": [{"param_description": "The path at which to write the contents of the array.If path contains a tilde (~) character, you must expand it with expandingTildeInPath before invoking this method.", "param_type": "String", "param_name": ["toFile", "path"]}, {"param_description": "", "param_type": "Bool", "param_name": ["atomically", "useAuxiliaryFile"]}]}, {"return_value": {"return_description": ["true if the location is written successfully, otherwise false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Writes the contents of the array to the location specified by a given URL.", "method_name": "write", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "URL", "param_name": ["to", "url"]}, {"param_description": "", "param_type": "Bool", "param_name": ["atomically"]}]}, {"return_value": {"return_description": ["An array containing all the pathname elements in the receiving array that have filename extensions from the filterTypes array."], "return_name": [""], "return_type": ["[String]"]}, "method_description": "Returns an array containing all the pathname elements in the receiving array that have filename extensions from a given array.", "method_name": "pathsMatchingExtensions", "class_name": "NSArray", "params": [{"param_description": "An array of NSString objects containing filename extensions. The extensions should not include the dot (\u201c.\u201d) character.", "param_type": "[String]", "param_name": ["filterTypes"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Raises an exception.", "method_name": "addObserver", "class_name": "NSArray", "params": [{"param_description": "The object to register for KVO notifications. The observer must implement the key-value observing method observeValue(forKeyPath:of:change:context:).", "param_type": "NSObject", "param_name": ["observer"]}, {"param_description": "The key path, relative to the array, of the property to observe. This value must not be nil.", "param_type": "String", "param_name": ["forKeyPath", "keyPath"]}, {"param_description": "A combination of NSKeyValueObservingOptions values that specifies what is included in observation notifications.", "param_type": "NSKeyValueObservingOptions", "param_name": ["options"]}, {"param_description": "Arbitrary data that is passed to observer in observeValue(forKeyPath:of:change:context:).", "param_type": "UnsafeMutableRawPointer", "param_name": ["context"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Raises an exception.", "method_name": "removeObserver", "class_name": "NSArray", "params": [{"param_description": "The object to remove as an observer.", "param_type": "NSObject", "param_name": ["observer"]}, {"param_description": "A key-path, relative to the array, for which observer is registered to receive KVO change notifications. This value must not be nil.", "param_type": "String", "param_name": ["forKeyPath", "keyPath"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Raises an exception.", "method_name": "removeObserver", "class_name": "NSArray", "params": [{"param_description": "The object to remove as an observer.", "param_type": "NSObject", "param_name": ["observer"]}, {"param_description": "A key-path, relative to the set, for which observer is registered to receive KVO change notifications. This value must not be nil.", "param_type": "String", "param_name": ["forKeyPath", "keyPath"]}, {"param_description": "The context passed to the notifications.", "param_type": "UnsafeMutableRawPointer", "param_name": ["context"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Raises an exception.", "method_name": "removeObserver", "class_name": "NSArray", "params": [{"param_description": "The object to remove as an observer.", "param_type": "NSObject", "param_name": ["observer"]}, {"param_description": "The index set.", "param_type": "IndexSet", "param_name": ["fromObjectsAt", "indexes"]}, {"param_description": "A key-path, relative to the array, for which observer is registered to receive KVO change notifications. This value must not be nil.", "param_type": "String", "param_name": ["forKeyPath", "keyPath"]}, {"param_description": "The context passed to the notifications.", "param_type": "UnsafeMutableRawPointer", "param_name": ["context"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Registers an observer to receive key value observer notifications for the specified key-path relative to the objects at the indexes. ", "method_name": "addObserver", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "NSObject", "param_name": ["observer"]}, {"param_description": "The index set.", "param_type": "IndexSet", "param_name": ["toObjectsAt", "indexes"]}, {"param_description": "The key path, relative to the array, to be observed.", "param_type": "String", "param_name": ["forKeyPath", "keyPath"]}, {"param_description": "The options to be included in the notification.", "param_type": "NSKeyValueObservingOptions", "param_name": ["options"]}, {"param_description": "The context passed to the notifications.", "param_type": "UnsafeMutableRawPointer", "param_name": ["context"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes anObserver from all key value observer notifications associated with the specified keyPath relative to the array\u2019s objects at indexes.", "method_name": "removeObserver", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "NSObject", "param_name": ["observer"]}, {"param_description": "The index set.", "param_type": "IndexSet", "param_name": ["fromObjectsAt", "indexes"]}, {"param_description": "The key path, relative to the array, to be observed.", "param_type": "String", "param_name": ["forKeyPath", "keyPath"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Invokes setValue(_:forKey:) on each of the array's items using the specified value and key.", "method_name": "setValue", "class_name": "NSArray", "params": [{"param_description": "The object value.", "param_type": "Any", "param_name": ["value"]}, {"param_description": "The key to store the value.", "param_type": "String", "param_name": ["forKey", "key"]}]}, {"return_value": {"return_description": ["The value of the retrieved key."], "return_name": [""], "return_type": ["Any"]}, "method_description": "Returns an array containing the results of invoking value(forKey:) using key on each of the array's objects.", "method_name": "value", "class_name": "NSArray", "params": [{"param_description": "The key to retrieve.", "param_type": "String", "param_name": ["forKey", "key"]}]}, {"return_value": {"return_description": ["A new array that lists this array\u2019s elements in a random order."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns a new array that lists this array\u2019s elements in a random order.", "method_name": "shuffled", "class_name": "NSArray", "params": []}, {"return_value": {"return_description": ["A new array that lists this array\u2019s elements in a random order."], "return_name": [""], "return_type": ["[Any]"]}, "method_description": "Returns a new array that lists this array\u2019s elements in a random order, using the specified random source.", "method_name": "shuffled", "class_name": "NSArray", "params": [{"param_description": "A GameplayKit random source object.", "param_type": "GKRandomSource", "param_name": ["using", "randomSource"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["NSFastEnumerationIterator"]}, "method_description": "Return an iterator over the elements of this sequence.", "method_name": "makeIterator", "class_name": "NSArray", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "", "method_name": "write", "class_name": "NSArray", "params": [{"param_description": "", "param_type": "URL", "param_name": ["to", "url"]}]}], "package_name": "swift"}