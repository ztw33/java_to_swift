{"class_description": "Swift provides a default debugging textual representation for any type. That default representation is used by the String(reflecting:) initializer and the debugPrint(_:) function for types that don\u2019t provide their own. To customize that representation, make your type conform to the CustomDebugStringConvertible protocol.\nBecause the String(reflecting:) initializer works for instances of any type, returning an instance\u2019s debugDescription if the value passed conforms to CustomDebugStringConvertible, accessing a type\u2019s debugDescription property directly or using CustomDebugStringConvertible as a generic constraint is discouraged.\nNote\nCalling the dump(_:_:_:_:) function and printing in the debugger uses both String(reflecting:) and Mirror(reflecting:) to collect information about an instance. If you implement CustomDebugStringConvertible conformance for your custom type, you may want to consider providing a custom mirror by implementing CustomReflectable conformance, as well.\nAdd CustomDebugStringConvertible conformance to your custom types by defining a debugDescription property.\nFor example, this custom Point struct uses the default representation supplied by the standard library:\nAfter adding CustomDebugStringConvertible conformance by implementing the debugDescription property, Point provides its own custom debugging representation.\n", "package_name": "swift", "interface_list": [], "Methods": [], "class_inherit_list": [], "Vars": [{"var_type": "String", "var_description": "A textual representation of this instance, suitable for debugging.Required. Default implementation provided.", "var_name": "debugDescription"}], "subclass_list": ["CodingKey", "ReferenceConvertible"], "class_name": "CustomDebugStringConvertible"}