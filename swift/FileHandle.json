{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable", "NSSecureCoding"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": ["Data"], "return_name": [""], "return_description": ["The data available through the receiver up to maximum size that can be represented by an NSData object or, if a communications channel, until an end-of-file indicator is returned."]}, "method_name": "readDataToEndOfFile", "class_name": "FileHandle", "method_description": "Synchronously reads the available data up to the end of file or maximum number of bytes.", "params": []}, {"return_value": {"return_type": ["Data"], "return_name": [""], "return_description": ["The data available through the receiver up to a maximum of length bytes, or the maximum size that can be represented by an NSData object, whichever is the smaller."]}, "method_name": "readData", "class_name": "FileHandle", "method_description": "Synchronously reads data up to the specified number of bytes.", "params": [{"param_type": "Int", "param_name": ["ofLength", "length"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "write", "class_name": "FileHandle", "method_description": "Synchronously writes the specified data to the receiver.", "params": [{"param_type": "Data", "param_name": ["data"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "acceptConnectionInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Accepts a socket connection (for stream-type sockets only) in the background and creates a file handle for the \u201cnear\u201d (client) end of the communications channel.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "acceptConnectionInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Accepts a socket connection (for stream-type sockets only) in the background and creates a file handle for the \u201cnear\u201d (client) end of the communications channel.", "params": [{"param_type": "[RunLoop.Mode]", "param_name": ["forModes", "modes"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "readInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Reads from the file or communications channel in the background and posts a notification when finished.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "readInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Reads from the file or communications channel in the background and posts a notification when finished.", "params": [{"param_type": "[RunLoop.Mode]", "param_name": ["forModes", "modes"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "readToEndOfFileInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Reads to the end of file from the file or communications channel in the background and posts a notification when finished.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "readToEndOfFileInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Reads to the end of file from the file or communications channel in the background and posts a notification when finished.", "params": [{"param_type": "[RunLoop.Mode]", "param_name": ["forModes", "modes"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "waitForDataInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Asynchronously checks to see if data is available.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "waitForDataInBackgroundAndNotify", "class_name": "FileHandle", "method_description": "Asynchronously checks to see if data is available.", "params": [{"param_type": "[RunLoop.Mode]", "param_name": ["forModes", "modes"], "param_description": ""}]}, {"return_value": {"return_type": ["UInt64"], "return_name": [""], "return_description": ["The file offset with the file pointer at the end of the file. This is therefore equal to the size of the file."]}, "method_name": "seekToEndOfFile", "class_name": "FileHandle", "method_description": "Puts the file pointer at the end of the file referenced by the receiver and returns the new file offset.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "seek", "class_name": "FileHandle", "method_description": "Moves the file pointer to the specified offset within the file represented by the receiver.", "params": [{"param_type": "UInt64", "param_name": ["toFileOffset", "offset"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "closeFile", "class_name": "FileHandle", "method_description": "Disallows further access to the represented file or communications channel and signals end of file on communications channels that permit writing.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "synchronizeFile", "class_name": "FileHandle", "method_description": "Causes all in-memory data and attributes of the file represented by the receiver to be written to permanent storage.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "truncateFile", "class_name": "FileHandle", "method_description": "Truncates or extends the file represented by the receiver to a specified offset within the file and puts the file pointer at that position.", "params": [{"param_type": "UInt64", "param_name": ["atOffset", "offset"], "param_description": ""}]}], "Vars": [{"var_type": "FileHandle", "var_description": "Returns the file handle associated with the standard error file.", "var_name": "standardError"}, {"var_type": "FileHandle", "var_description": "Returns the file handle associated with the standard input file.", "var_name": "standardInput"}, {"var_type": "FileHandle", "var_description": "Returns the file handle associated with the standard output file.", "var_name": "standardOutput"}, {"var_type": "FileHandle", "var_description": "Returns a file handle associated with a null device.", "var_name": "nullDevice"}, {"var_type": "Int32", "var_description": "The POSIX file descriptor associated with the receiver.", "var_name": "fileDescriptor"}, {"var_type": "Data", "var_description": "The data currently available in the receiver.", "var_name": "availableData"}, {"var_type": "((FileHandle)", "var_description": "The block to use for reading the contents of the file handle asynchronously.", "var_name": "readabilityHandler"}, {"var_type": "((FileHandle)", "var_description": "The block to use for writing the contents of the file handle asynchronously.", "var_name": "writeabilityHandler"}, {"var_type": "UInt64", "var_description": "The position of the file pointer within the file represented by the receiver.", "var_name": "offsetInFile"}, {"var_type": "String", "var_description": "A key in the userinfo dictionary in a NSFileHandleConnectionAccepted notification.", "var_name": "NSFileHandleNotificationFileHandleItem"}, {"var_type": "String", "var_description": "A key in the userinfo dictionary in a readCompletionNotification and NSFileHandleReadToEndOfFileCompletion.", "var_name": "NSFileHandleNotificationDataItem"}, {"var_type": "String", "var_description": "Currently unused.", "var_name": "NSFileHandleNotificationMonitorModes"}, {"var_type": "NSExceptionName", "var_description": "Raised by NSFileHandle if attempts to determine file-handle type fail or if attempts to read from a file or channel fail.", "var_name": "fileHandleOperationException"}, {"var_type": "NSNotification.Name", "var_description": "This notification is posted when an NSFileHandle object establishes a socket connection between two processes, creates an NSFileHandle object for one end of the connection, and makes this object available to observers by putting it in the userInfo dictionary.", "var_name": "NSFileHandleConnectionAccepted"}, {"var_type": "NSNotification.Name", "var_description": "This notification is posted when the file handle determines that data is currently available for reading in a file or at a communications channel.", "var_name": "NSFileHandleDataAvailable"}, {"var_type": "NSNotification.Name", "var_description": "This notification is posted when the file handle reads the data currently available in a file or at a communications channel.", "var_name": "readCompletionNotification"}, {"var_type": "NSNotification.Name", "var_description": "This notification is posted when the file handle reads all data in the file or, if a communications channel, until the other process signals the end of data.", "var_name": "NSFileHandleReadToEndOfFileCompletion"}], "subclass_list": [], "class_description": "You use file handle objects to access data associated with files, sockets, pipes, and devices. For files, you can read, write, and seek within the file. For sockets, pipes, and devices, you can use a file handle object to monitor the device and process data asynchronously.\nMost creation methods for FileHandle cause the file handle object to take ownership of the associated file descriptor. This means that the file handle object both creates the file descriptor and is responsible for closing it later, usually when the file handle object itself is deallocated. If you want to use a file handle object with a file descriptor that you created, use the init(fileDescriptor:) method or use the init(fileDescriptor:closeOnDealloc:) method and pass false for the flag parameter.\nWhen using a file handle object to communicate asynchronously with a socket, you must initiate the corresponding operations from a thread with an active run loop. Although the read, accept, and wait operations themselves are performed asynchronously on background threads, the file handle uses a run loop source to monitor the operations and notify your code appropriately. Therefore, you must call those methods from your application\u2019s main thread or from any thread where you have configured a run loop and are using it to process events.\nFor more information about configuring and using run loops, see Threading Programming Guide.  \n", "class_name": "FileHandle"}