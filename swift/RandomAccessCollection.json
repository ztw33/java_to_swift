{"class_description": "Random-access collections can move indices any distance and measure the distance between indices in O(1) time. Therefore, the fundamental difference between random-access and bidirectional collections is that operations that depend on index movement or distance measurement offer significantly improved efficiency. For example, a random-access collection\u2019s count property is calculated in O(1) instead of requiring iteration of an entire collection.\nThe RandomAccessCollection protocol adds further constraints on the associated Indices and SubSequence types, but otherwise imposes no additional requirements over the BidirectionalCollection protocol. However, in order to meet the complexity guarantees of a random-access collection, either the index for your custom type must conform to the Strideable protocol or you must implement the index(_:offsetBy:) and distance(from:to:) methods with O(1) efficiency.\n", "package_name": "swift", "interface_list": [], "Methods": [{"return_value": {"return_name": [""], "return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_type": ["Int"]}, "class_name": "RandomAccessCollection", "method_description": "Returns the distance between two indices.Required. Default implementation provided.", "method_name": "distance", "params": [{"param_type": "Self.Index", "param_name": ["from", "start"], "param_description": "A valid index of the collection."}, {"param_type": "Self.Index", "param_name": ["to", "end"], "param_description": "Another valid index of the collection. If end is equal to start, the result is zero."}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "RandomAccessCollection", "method_description": "Replaces the given index with its successor.Required.", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["after", "i"], "param_description": "A valid index of the collection. i must be less than endIndex."}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "RandomAccessCollection", "method_description": "Replaces the given index with its predecessor.Required.", "method_name": "formIndex", "params": [{"param_type": "inout Self.Index", "param_name": ["before", "i"], "param_description": "A valid index of the collection. i must be greater than startIndex."}]}, {"return_value": {"return_name": [""], "return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_type": ["Self.Index"]}, "class_name": "RandomAccessCollection", "method_description": "Returns an index that is the specified distance from the given index.Required. Default implementation provided.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["i"], "param_description": "A valid index of the collection."}, {"param_type": "Int", "param_name": ["offsetBy", "distance"], "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol."}]}, {"return_value": {"return_name": [""], "return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_type": ["Self.Index"]}, "class_name": "RandomAccessCollection", "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.Required. Default implementation provided.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["i"], "param_description": "A valid index of the collection."}, {"param_type": "Int", "param_name": ["offsetBy", "distance"], "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol."}, {"param_type": "Self.Index", "param_name": ["limitedBy", "limit"], "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect."}]}, {"return_value": {"return_name": [""], "return_description": ["The index value immediately after i."], "return_type": ["Self.Index"]}, "class_name": "RandomAccessCollection", "method_description": "Returns the position immediately after the given index.Required. Default implementation provided.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["after", "i"], "param_description": "A valid index of the collection. i must be less than endIndex."}]}, {"return_value": {"return_name": [""], "return_description": ["The index value immediately before i."], "return_type": ["Self.Index"]}, "class_name": "RandomAccessCollection", "method_description": "Returns the position immediately before the given index.Required. Default implementation provided.", "method_name": "index", "params": [{"param_type": "Self.Index", "param_name": ["before", "i"], "param_description": "A valid index of the collection. i must be greater than startIndex."}]}], "class_inherit_list": ["BidirectionalCollection"], "Vars": [{"var_type": "Self.Index", "var_description": "Required.", "var_name": "endIndex"}, {"var_type": "Self.Indices", "var_description": "The indices that are valid for subscripting the collection, in ascending order.Required. Default implementation provided.", "var_name": "indices"}, {"var_type": "Self.Index", "var_description": "Required.", "var_name": "startIndex"}], "subclass_list": [], "class_name": "RandomAccessCollection"}