{"package_name": "foundation", "interface_list": [], "class_inherit_list": [], "Methods": [], "Vars": [{"var_type": "Bool", "var_description": "True if the resource is scriptable. Only applies to applications.", "var_name": "applicationIsScriptable"}, {"var_type": "Bool", "var_description": "True if resource is an application.", "var_name": "isApplication"}, {"var_type": "Bool", "var_description": "True for directories.", "var_name": "isDirectory"}, {"var_type": "Int", "var_description": "The document identifier \u2013 a value assigned by the kernel to a document (which can be either a file or directory) and is used to identify the document regardless of where it gets moved on a volume.", "var_name": "documentIdentifier"}, {"var_type": "Int", "var_description": "Total size allocated on disk for the file in bytes (number of blocks times block size)", "var_name": "fileAllocatedSize"}, {"var_type": "URLFileProtection", "var_description": "The protection level for this file", "var_name": "fileProtection"}, {"var_type": "(NSCopying", "var_description": "An identifier which can be used to compare two file system objects for equality using isEqual.", "var_name": "fileResourceIdentifier"}, {"var_type": "URLFileResourceType", "var_description": "Returns the file system object type.", "var_name": "fileResourceType"}, {"var_type": "NSFileSecurity", "var_description": "The file system object\u2019s security information encapsulated in a FileSecurity object.", "var_name": "fileSecurity"}, {"var_type": "Int", "var_description": "Total file size in bytes", "var_name": "fileSize"}, {"var_type": "Bool", "var_description": "True if this process (as determined by EUID) can execute a file resource or search a directory resource.", "var_name": "isExecutable"}, {"var_type": "Bool", "var_description": "True for regular files.", "var_name": "isRegularFile"}, {"var_type": "Int", "var_description": "Total allocated size of the file in bytes (this may include space used by metadata), or nil if not available. This can be less than the value returned by totalFileSize if the resource is compressed.", "var_name": "totalFileAllocatedSize"}, {"var_type": "Int", "var_description": "Total displayable size of the file in bytes (this may include space used by metadata), or nil if not available.", "var_name": "totalFileSize"}, {"var_type": "Int", "var_description": "The volume\u2019s available capacity in bytes.", "var_name": "volumeAvailableCapacity"}, {"var_type": "Int64", "var_description": "The volume\u2019s available capacity in bytes for storing important resources.", "var_name": "volumeAvailableCapacityForImportantUsage"}, {"var_type": "Int64", "var_description": "The volume\u2019s available capacity in bytes for storing nonessential resources.", "var_name": "volumeAvailableCapacityForOpportunisticUsage"}, {"var_type": "Int", "var_description": "The volume\u2019s total capacity in bytes.", "var_name": "volumeTotalCapacity"}, {"var_type": "Bool", "var_description": "true if the volume is automounted. Note: do not mistake this with the functionality provided by kCFURLVolumeSupportsBrowsingKey.", "var_name": "volumeIsAutomounted"}, {"var_type": "Bool", "var_description": "True if the volume should be visible through the user interface (in effect, appear on the Desktop as a separate volume).", "var_name": "volumeIsBrowsable"}, {"var_type": "Bool", "var_description": "true if the volume\u2019s media is ejectable from the drive mechanism under software control.", "var_name": "volumeIsEjectable"}, {"var_type": "Bool", "var_description": "true if the volume is encrypted.", "var_name": "volumeIsEncrypted"}, {"var_type": "Bool", "var_description": "true if the volume\u2019s device is connected to an internal bus, false if connected to an external bus, or nil if not available.", "var_name": "volumeIsInternal"}, {"var_type": "Bool", "var_description": "true if the volume is currently using a journal for speedy recovery after an unplanned restart.", "var_name": "volumeIsJournaling"}, {"var_type": "Bool", "var_description": "true if the volume is stored on a local device.", "var_name": "volumeIsLocal"}, {"var_type": "Bool", "var_description": "true if the volume is read-only.", "var_name": "volumeIsReadOnly"}, {"var_type": "Bool", "var_description": "true if the volume\u2019s media is removable from the drive mechanism.", "var_name": "volumeIsRemovable"}, {"var_type": "Bool", "var_description": "true if the volume is the root filesystem.", "var_name": "volumeIsRootFileSystem"}, {"var_type": "Bool", "var_description": "True if this URL is a file system trigger directory. Traversing or opening a file system trigger will cause an attempt to mount a file system on the trigger directory.", "var_name": "isMountTrigger"}, {"var_type": "Bool", "var_description": "True for the root directory of a volume.", "var_name": "isVolume"}, {"var_type": "URL", "var_description": "URL of the volume on which the resource is stored.", "var_name": "volume"}, {"var_type": "Date", "var_description": "The volume\u2019s creation date, or nil if this cannot be determined.", "var_name": "volumeCreationDate"}, {"var_type": "(NSCopying", "var_description": "An identifier that can be used to identify the volume the file system object is on.", "var_name": "volumeIdentifier"}, {"var_type": "String", "var_description": "The user-visible volume format.", "var_name": "volumeLocalizedFormatDescription"}, {"var_type": "String", "var_description": "The user-presentable name of the volume", "var_name": "volumeLocalizedName"}, {"var_type": "Int", "var_description": "The largest file size (in bytes) supported by this file system, or nil if this cannot be determined.", "var_name": "volumeMaximumFileSize"}, {"var_type": "String", "var_description": "The name of the volume", "var_name": "volumeName"}, {"var_type": "Int", "var_description": "Total number of resources on the volume.", "var_name": "volumeResourceCount"}, {"var_type": "Bool", "var_description": "true if the volume implements whole-file flock(2) style advisory locks, and the O_EXLOCK and O_SHLOCK flags of the open(2) call.", "var_name": "volumeSupportsAdvisoryFileLocking"}, {"var_type": "Bool", "var_description": "true if the volume format preserves the case of file and directory names.  Otherwise the volume may change the case of some characters (typically making them all upper or all lower case).", "var_name": "volumeSupportsCasePreservedNames"}, {"var_type": "Bool", "var_description": "true if the volume format treats upper and lower case characters in file and directory names as different. Otherwise an upper case character is equivalent to a lower case character, and you can\u2019t have two names that differ solely in the case of the characters.", "var_name": "volumeSupportsCaseSensitiveNames"}, {"var_type": "Bool", "var_description": "true if the volume supports transparent decompression of compressed files using decmpfs.", "var_name": "volumeSupportsCompression"}, {"var_type": "Bool", "var_description": "true if the volume implements extended security (ACLs).", "var_name": "volumeSupportsExtendedSecurity"}, {"var_type": "Bool", "var_description": "true if the volume format supports hard links.", "var_name": "volumeSupportsHardLinks"}, {"var_type": "Bool", "var_description": "true if the volume format supports a journal used to speed recovery in case of unplanned restart (such as a power outage or crash). This does not necessarily mean the volume is actively using a journal.", "var_name": "volumeSupportsJournaling"}, {"var_type": "Bool", "var_description": "true if the volume format supports persistent object identifiers and can look up file system objects by their IDs.", "var_name": "volumeSupportsPersistentIDs"}, {"var_type": "Bool", "var_description": "true if the volume can be renamed.", "var_name": "volumeSupportsRenaming"}, {"var_type": "Bool", "var_description": "true if the volume supports reliable storage of times for the root directory.", "var_name": "volumeSupportsRootDirectoryDates"}, {"var_type": "Bool", "var_description": "true if the volume format supports sparse files, that is, files which can have \u2018holes\u2019 that have never been written to, and thus do not consume space on disk. A sparse file may have an allocated size on disk that is less than its logical length.", "var_name": "volumeSupportsSparseFiles"}, {"var_type": "Bool", "var_description": "true if the volume format supports symbolic links.", "var_name": "volumeSupportsSymbolicLinks"}, {"var_type": "Bool", "var_description": "true if the volume supports returning volume size values (volumeTotalCapacity and volumeAvailableCapacity).", "var_name": "volumeSupportsVolumeSizes"}, {"var_type": "Bool", "var_description": "For security reasons, parts of a file (runs) that have never been written to must appear to contain zeroes. true if the volume keeps track of allocated but unwritten runs of a file so that it can substitute zeroes without actually writing zeroes to the media.", "var_name": "volumeSupportsZeroRuns"}, {"var_type": "URL", "var_description": "The URL needed to remount a network volume, or nil if not available.", "var_name": "volumeURLForRemounting"}, {"var_type": "String", "var_description": "The volume\u2019s persistent UUID as a string, or nil if a persistent UUID is not available for the volume.", "var_name": "volumeUUIDString"}, {"var_type": "Bool", "var_description": "true if this item is synced to the cloud, false if it is only a local file.", "var_name": "isUbiquitousItem"}, {"var_type": "Bool", "var_description": "", "var_name": "ubiquitousItemIsShared"}, {"var_type": "URLUbiquitousSharedItemPermissions", "var_description": "", "var_name": "ubiquitousSharedItemCurrentUserPermissions"}, {"var_type": "URLUbiquitousSharedItemRole", "var_description": "", "var_name": "ubiquitousSharedItemCurrentUserRole"}, {"var_type": "PersonNameComponents", "var_description": "", "var_name": "ubiquitousSharedItemMostRecentEditorNameComponents"}, {"var_type": "PersonNameComponents", "var_description": "", "var_name": "ubiquitousSharedItemOwnerNameComponents"}, {"var_type": "String", "var_description": "returns the name of this item\u2019s container as displayed to users.", "var_name": "ubiquitousItemContainerDisplayName"}, {"var_type": "Bool", "var_description": "returns whether a download of this item has already been requested with an API like startDownloadingUbiquitousItem(at:) throws.", "var_name": "ubiquitousItemDownloadRequested"}, {"var_type": "NSError", "var_description": "returns the error when downloading the item from iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h", "var_name": "ubiquitousItemDownloadingError"}, {"var_type": "URLUbiquitousItemDownloadingStatus", "var_description": "returns the download status of this item.", "var_name": "ubiquitousItemDownloadingStatus"}, {"var_type": "Bool", "var_description": "true if this item has conflicts outstanding.", "var_name": "ubiquitousItemHasUnresolvedConflicts"}, {"var_type": "Bool", "var_description": "true if data is being downloaded for this item.", "var_name": "ubiquitousItemIsDownloading"}, {"var_type": "Bool", "var_description": "true if there is data present in the cloud for this item.", "var_name": "ubiquitousItemIsUploaded"}, {"var_type": "Bool", "var_description": "true if data is being uploaded for this item.", "var_name": "ubiquitousItemIsUploading"}, {"var_type": "NSError", "var_description": "returns the error when uploading the item to iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h", "var_name": "ubiquitousItemUploadingError"}, {"var_type": "NSImage", "var_description": "", "var_name": "thumbnail"}, {"var_type": "[URLThumbnailDictionaryItem", "var_description": "", "var_name": "thumbnailDictionary"}, {"var_type": "[URLThumbnailDictionaryItem", "var_description": "", "var_name": "thumbnailDictionary"}, {"var_type": "Date", "var_description": "The date the resource was created, or renamed into or within its parent directory. ", "var_name": "addedToDirectoryDate"}, {"var_type": "[URLResourceKey", "var_description": "A loosely-typed dictionary containing all keys and values.", "var_name": "allValues"}, {"var_type": "Date", "var_description": "The time the resource\u2019s attributes were last modified.", "var_name": "attributeModificationDate"}, {"var_type": "String", "var_description": "The URL\u2019s path as a canonical absolute file system path.", "var_name": "canonicalPath"}, {"var_type": "Date", "var_description": "The date the resource was last accessed.", "var_name": "contentAccessDate"}, {"var_type": "Date", "var_description": "The time the resource content was last modified.", "var_name": "contentModificationDate"}, {"var_type": "Date", "var_description": "The date the resource was created.", "var_name": "creationDate"}, {"var_type": "NSImage", "var_description": "", "var_name": "customIcon"}, {"var_type": "AnyObject", "var_description": "", "var_name": "effectiveIcon"}, {"var_type": "(NSCopying", "var_description": "An opaque generation identifier which can be compared using == to determine if the data in a document has been modified.", "var_name": "generationIdentifier"}, {"var_type": "Bool", "var_description": "True for resources whose filename extension is removed from the localized name property.", "var_name": "hasHiddenExtension"}, {"var_type": "Bool", "var_description": "true if the resource is a Finder alias file or a symlink, false otherwise", "var_name": "isAliasFile"}, {"var_type": "Bool", "var_description": "True if resource should be excluded from backups, false otherwise.", "var_name": "isExcludedFromBackup"}, {"var_type": "Bool", "var_description": "True for resources normally not displayed to users.", "var_name": "isHidden"}, {"var_type": "Bool", "var_description": "True for packaged directories.", "var_name": "isPackage"}, {"var_type": "Bool", "var_description": "True if this process (as determined by EUID) can read the resource.", "var_name": "isReadable"}, {"var_type": "Bool", "var_description": "True for symlinks.", "var_name": "isSymbolicLink"}, {"var_type": "Bool", "var_description": "True for system-immutable resources.", "var_name": "isSystemImmutable"}, {"var_type": "Bool", "var_description": "True for user-immutable resources", "var_name": "isUserImmutable"}, {"var_type": "Bool", "var_description": "True if this process (as determined by EUID) can write to the resource.", "var_name": "isWritable"}, {"var_type": "NSColor", "var_description": "", "var_name": "labelColor"}, {"var_type": "Int", "var_description": "The label number assigned to the resource.", "var_name": "labelNumber"}, {"var_type": "Int", "var_description": "Number of hard links to the resource.", "var_name": "linkCount"}, {"var_type": "String", "var_description": "The user-visible label text.", "var_name": "localizedLabel"}, {"var_type": "String", "var_description": "Localized or extension-hidden name as displayed to users.", "var_name": "localizedName"}, {"var_type": "String", "var_description": "User-visible type or \u201ckind\u201d description.", "var_name": "localizedTypeDescription"}, {"var_type": "String", "var_description": "The resource name provided by the file system.", "var_name": "name"}, {"var_type": "URL", "var_description": "The resource\u2019s parent directory, if any.", "var_name": "parentDirectory"}, {"var_type": "String", "var_description": "The URL\u2019s path as a file system path.", "var_name": "path"}, {"var_type": "Int", "var_description": "The optimal block size when reading or writing this file\u2019s data, or nil if not available.", "var_name": "preferredIOBlockSize"}, {"var_type": "[String", "var_description": "The quarantine properties as defined in LSQuarantine.h. To remove quarantine information from a file, pass nil as the value when setting this property.", "var_name": "quarantineProperties"}, {"var_type": "[String]", "var_description": "The array of Tag names.", "var_name": "tagNames"}, {"var_type": "String", "var_description": "Uniform type identifier (UTI) for the resource.", "var_name": "typeIdentifier"}, {"var_type": "Bool", "var_description": "", "var_name": "volumeSupportsAccessPermissions"}, {"var_type": "Bool", "var_description": "", "var_name": "volumeSupportsExclusiveRenaming"}, {"var_type": "Bool", "var_description": "", "var_name": "volumeSupportsFileCloning"}, {"var_type": "Bool", "var_description": "", "var_name": "volumeSupportsImmutableFiles"}, {"var_type": "Bool", "var_description": "", "var_name": "volumeSupportsSwapRenaming"}], "subclass_list": [], "class_description": "URLs to file system resources support the properties defined below. Note that not all property values will exist for all file system URLs. For example, if a file is located on a volume that does not support creation dates, it is valid to request the creation date property, but the returned value will be nil, and no error will be generated.\nOnly the fields requested by the keys you pass into the URL function to receive this value will be populated. The others will return nil regardless of the underlying property on the file system.\nAs a convenience, volume resource values can be requested from any file system URL. The value returned will reflect the property value for the volume on which the resource is located.\n", "class_name": "URLResourceValues"}