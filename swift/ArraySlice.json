{"class_inherit_list": [], "Vars": [{"var_description": "The total number of elements that the array can contain without allocating new storage.", "var_type": "Int", "var_name": "capacity"}, {"var_description": "The number of elements in the array.", "var_type": "Int", "var_name": "count"}, {"var_description": "The number of elements in the collection.", "var_type": "Int", "var_name": "count"}, {"var_description": "A mirror that reflects the array.", "var_type": "Mirror", "var_name": "customMirror"}, {"var_description": "A textual representation of the array and its elements, suitable for debugging.", "var_type": "String", "var_name": "debugDescription"}, {"var_description": "A textual representation of the array and its elements.", "var_type": "String", "var_name": "description"}, {"var_description": "The array\u2019s \u201cpast the end\u201d position\u2014that is, the position one greater than the last valid subscript argument.", "var_type": "Int", "var_name": "endIndex"}, {"var_description": "The first element of the collection.", "var_type": "Element", "var_name": "first"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "Range<Int>", "var_name": "indices"}, {"var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool", "var_name": "isEmpty"}, {"var_description": "The last element of the collection.", "var_type": "Element", "var_name": "last"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<ArraySlice<Element>>", "var_name": "lazy"}, {"var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<ArraySlice<Element>>", "var_name": "lazy"}, {"var_description": "The position of the first element in a nonempty array.", "var_type": "Int", "var_name": "startIndex"}, {"var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "var_type": "Int", "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "var_name": "underestimatedCount"}], "class_name": "ArraySlice", "interface_list": ["CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "MutableCollection", "RandomAccessCollection", "RangeReplaceableCollection"], "subclass_list": [], "class_description": "The ArraySlice type makes it fast and efficient for you to perform operations on sections of a larger array. Instead of copying over the elements of a slice to new storage, an ArraySlice instance presents a view onto the storage of a larger array. And because ArraySlice presents the same interface as Array, you can generally perform the same operations on a slice as you could on the original array.\nFor more information about using arrays, see Array and ContiguousArray, with which ArraySlice shares most properties and methods.\nFor example, suppose you have an array holding the number of absences from each class during a session.\nYou want to compare the absences in the first half of the session with those in the second half. To do so, start by creating two slices of the absences array.\nNeither the firstHalf nor secondHalf slices allocate any new storage of their own. Instead, each presents a view onto the storage of the absences array.\nYou can call any method on the slices that you might have called on the absences array. To learn which half had more absences, use the reduce(_:_:) method to calculate each sum.\nImportant\nLong-term storage of ArraySlice instances is discouraged. A slice holds a reference to the entire storage of a larger array, not just to the portion it presents, even after the original array\u2019s lifetime ends. Long-term storage of a slice may therefore prolong the lifetime of elements that are no longer otherwise accessible, which can appear to be memory and object leakage.\nUnlike Array and ContiguousArray, the starting index for an ArraySlice instance isn\u2019t always zero. Slices maintain the same indices of the larger array for the same elements, so the starting index of a slice depends on how it was created, letting you perform index-based operations on either a full array or a slice.\nSharing indices between collections and their subsequences is an important part of the design of Swift\u2019s collection algorithms. Suppose you are tasked with finding the first two days with absences in the session. To find the indices of the two days in question, follow these steps:\nCall firstIndex(where:) to find the index of the first element in the absences array that is greater than zero.\nCreate a slice of the absences array starting after the index found in step 1.\nCall firstIndex(where:) again, this time on the slice created in step\nWhere in some languages you might pass a starting index into an indexOf method to find the second day, in Swift you perform the same operation on a slice of the original array.\nPrint the results using the indices found in steps 1 and 3 on the original absences array.\nHere\u2019s an implementation of those steps:\nIn particular, note that j, the index of the second day with absences, was found in a slice of the original array and then used to access a value in the original absences array itself.\nNote\nTo safely reference the starting and ending indices of a slice, always use the startIndex and endIndex properties instead of specific values.\n", "Methods": [{"return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "(Element", "param_name": ["predicate"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Adds an element to the end of the collection.", "method_name": "append", "class_name": "ArraySlice", "params": [{"param_description": "The element to append to the collection.", "param_type": "Element", "param_name": ["newElement"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Adds a new element at the end of the array.", "method_name": "append", "class_name": "ArraySlice", "params": [{"param_description": "The element to append to the array.", "param_type": "ArraySlice<Element>.Element", "param_name": ["newElement"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Adds the elements of a sequence to the end of the array.", "method_name": "append", "class_name": "ArraySlice", "params": [{"param_description": "The elements to append to the array.", "param_type": "Sequence", "param_name": ["contentsOf", "newElements"]}]}, {"return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "class_name": "ArraySlice", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "(Element", "param_name": ["transform"]}]}, {"return_value": {"return_description": ["true if the element was found in the sequence; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "method_name": "contains", "class_name": "ArraySlice", "params": [{"param_description": "The element to find in the sequence.", "param_type": "Element", "param_name": ["element"]}]}, {"return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": ["The distance between start and end."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the distance between two indices.", "method_name": "distance", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection.", "param_type": "Int", "param_name": ["from", "start"]}, {"param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_type": "Int", "param_name": ["to", "end"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> ArraySlice<Element>"]}, "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_type": "(Element", "param_name": ["while", "predicate"]}]}, {"return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence containing all but the first element of the sequence.", "method_name": "dropFirst", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": ["A subsequence leaving off the last element of the sequence."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence containing all but the last element of the sequence.", "method_name": "dropLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "method_name": "elementsEqual", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}]}, {"return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(Element", "param_name": ["by", "areEquivalent"]}, {"param_description": "", "param_type": "Sequence.Element", "param_name": ["Sequence.Element"]}]}, {"return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<ArraySlice<Element>>"]}, "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["An array of the elements that isIncluded allowed."], "return_name": [""], "return_type": ["Bool rethrows -> [Element]"]}, "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "method_name": "filter", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_type": "(Element", "param_name": ["isIncluded"]}]}, {"return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the first index where the specified value appears in the collection.", "method_name": "firstIndex", "class_name": "ArraySlice", "params": [{"param_description": "An element to search for in the collection.", "param_type": "Element", "param_name": ["of", "element"]}]}, {"return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["String rethrows -> [String]"]}, "method_description": "", "method_name": "flatMap", "class_name": "ArraySlice", "params": [{"param_description": "", "param_type": "(Element", "param_name": ["transform"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "(Element", "param_name": ["body"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection.", "param_type": "inout Int", "param_name": ["i"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}]}, {"return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection.", "param_type": "inout Int", "param_name": ["i"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}, {"param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_type": "Int", "param_name": ["limitedBy", "limit"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Replaces the given index with its successor.", "method_name": "formIndex", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection. i must be less than endIndex.", "param_type": "inout Int", "param_name": ["after", "i"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Replaces the given index with its predecessor.", "method_name": "formIndex", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection. i must be greater than startIndex.", "param_type": "inout Int", "param_name": ["before", "i"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "class_name": "ArraySlice", "params": [{"param_description": "The hasher to use when combining the components of this instance.", "param_type": "inout Hasher", "param_name": ["into", "hasher"]}]}, {"return_value": {"return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the array.", "param_type": "Int", "param_name": ["i"]}, {"param_description": "The distance to offset i.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}]}, {"return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the array.", "param_type": "Int", "param_name": ["i"]}, {"param_description": "The distance to offset i.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}, {"param_description": "A valid index of the collection to use as a limit. If distance > 0, limit has no effect if it is less than i. Likewise, if distance < 0, limit has no effect if it is greater than i.", "param_type": "Int", "param_name": ["limitedBy", "limit"]}]}, {"return_value": {"return_description": ["The index immediately after i."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the position immediately after the given index.", "method_name": "index", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection. i must be less than endIndex.", "param_type": "Int", "param_name": ["after", "i"]}]}, {"return_value": {"return_description": ["The index immediately before i."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the position immediately before the given index.", "method_name": "index", "class_name": "ArraySlice", "params": [{"param_description": "A valid index of the collection. i must be greater than startIndex.", "param_type": "Int", "param_name": ["before", "i"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Inserts a new element into the collection at the specified position.", "method_name": "insert", "class_name": "ArraySlice", "params": [{"param_description": "The new element to insert into the collection.", "param_type": "Element", "param_name": ["newElement"]}, {"param_description": "The position at which to insert the new element. index must be a valid index into the collection.", "param_type": "Int", "param_name": ["at", "i"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Inserts a new element at the specified position.", "method_name": "insert", "class_name": "ArraySlice", "params": [{"param_description": "The new element to insert into the array.", "param_type": "ArraySlice<Element>.Element", "param_name": ["newElement"]}, {"param_description": "The position at which to insert the new element. index must be a valid index of the array or equal to its endIndex property.", "param_type": "Int", "param_name": ["at", "i"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Inserts the elements of a sequence into the collection at the specified position.", "method_name": "insert", "class_name": "ArraySlice", "params": [{"param_description": "The new elements to insert into the collection.", "param_type": "Collection", "param_name": ["contentsOf", "newElements"]}, {"param_description": "The position at which to insert the new elements. index must be a valid index of the collection.", "param_type": "Int", "param_name": ["at", "i"]}]}, {"return_value": {"return_description": ["A flattened view of the elements of this sequence of sequences."], "return_name": [""], "return_type": ["FlattenSequence<ArraySlice<Element>>"]}, "method_description": "Returns the elements of this sequence of sequences, concatenated.", "method_name": "joined", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["A flattened view of the elements of this collection of collections."], "return_name": [""], "return_type": ["FlattenCollection<ArraySlice<Element>>"]}, "method_description": "Returns the elements of this collection of collections, concatenated.", "method_name": "joined", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The joined sequence of elements."], "return_name": [""], "return_type": ["JoinedSequence<ArraySlice<Element>>"]}, "method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "method_name": "joined", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to insert between each of this sequence\u2019s elements.", "param_type": "Sequence", "param_name": ["separator"]}]}, {"return_value": {"return_description": ["A single, concatenated string."], "return_name": [""], "return_type": ["String"]}, "method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "method_name": "joined", "class_name": "ArraySlice", "params": [{"param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_type": "String", "param_name": ["separator"]}]}, {"return_value": {"return_description": ["A single, concatenated string."], "return_name": [""], "return_type": ["String"]}, "method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "method_name": "joined", "class_name": "ArraySlice", "params": [{"param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_type": "String", "param_name": ["separator"]}]}, {"return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the last element of the sequence that satisfies the given predicate.", "method_name": "last", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the last index where the specified value appears in the collection.", "method_name": "lastIndex", "class_name": "ArraySlice", "params": [{"param_description": "An element to search for in the collection.", "param_type": "Element", "param_name": ["of", "element"]}]}, {"return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the index of the last element in the collection that matches the given predicate.", "method_name": "lastIndex", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "method_name": "lexicographicallyPrecedes", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}]}, {"return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<ArraySlice<Element>>"]}, "method_description": "Returns an iterator over the elements of the collection.", "method_name": "makeIterator", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "class_name": "ArraySlice", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(Element", "param_name": ["transform"]}]}, {"return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "class_name": "ArraySlice", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(Element", "param_name": ["transform"]}]}, {"return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Returns the maximum element in the sequence.", "method_name": "max", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Bool rethrows -> Element"]}, "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "class_name": "ArraySlice", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Returns the minimum element in the sequence.", "method_name": "min", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Bool rethrows -> Element"]}, "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "class_name": "ArraySlice", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["Bool rethrows -> Int"]}, "method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "method_name": "partition", "class_name": "ArraySlice", "params": [{"param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_type": "(Element", "param_name": ["by", "belongsInSecondPartition"]}]}, {"return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["Bool rethrows -> Int"]}, "method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "method_name": "partition", "class_name": "ArraySlice", "params": [{"param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_type": "(Element", "param_name": ["by", "belongsInSecondPartition"]}]}, {"return_value": {"return_description": ["The first element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the first element of the collection.", "method_name": "popFirst", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The last element of the collection if the collection has one or more elements; otherwise, nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the last element of the collection.", "method_name": "popLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The last element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the last element of the collection.", "method_name": "popLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The last element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the last element of the collection.", "method_name": "popLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "class_name": "ArraySlice", "params": [{"param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_type": "Int", "param_name": ["maxLength"]}]}, {"return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "class_name": "ArraySlice", "params": [{"param_description": "", "param_type": "Int", "param_name": ["through", "position"]}]}, {"return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "class_name": "ArraySlice", "params": [{"param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_type": "Int", "param_name": ["upTo", "end"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> ArraySlice<Element>"]}, "method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_type": "(Element", "param_name": ["while", "predicate"]}]}, {"return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Returns a random element of the collection.", "method_name": "randomElement", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "class_name": "ArraySlice", "params": [{"param_description": "The random number generator to use when choosing a random element.", "param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"]}]}, {"return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result rethrows -> Result"]}, "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "class_name": "ArraySlice", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result", "param_name": ["nextPartialResult"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["rethrows -> Result"]}, "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "class_name": "ArraySlice", "params": [{"param_description": "The value to use as the initial accumulating value.", "param_type": "Result", "param_name": ["into", "initialResult"]}, {"param_description": "A closure that updates the accumulating value with an element of the sequence.", "param_type": "(inout Result", "param_name": ["updateAccumulatingResult"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the element at the specified position.", "method_name": "remove", "class_name": "ArraySlice", "params": [{"param_description": "The position of the element to remove. position must be a valid index of the collection that is not equal to the collection\u2019s end index.", "param_type": "Int", "param_name": ["at", "position"]}]}, {"return_value": {"return_description": ["The element at the specified index."], "return_name": [""], "return_type": ["ArraySlice<Element>.Element"]}, "method_description": "Removes and returns the element at the specified position.", "method_name": "remove", "class_name": "ArraySlice", "params": [{"param_description": "The position of the element to remove. index must be a valid index of the array.", "param_type": "Int", "param_name": ["at", "index"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes all elements from the collection.", "method_name": "removeAll", "class_name": "ArraySlice", "params": [{"param_description": "Pass true to request that the collection avoid releasing its storage. Retaining the collection\u2019s storage can be a useful optimization when you\u2019re planning to grow the collection again. The default value is false.", "param_type": "Bool", "param_name": ["keepingCapacity", "keepCapacity"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes all elements from the array.", "method_name": "removeAll", "class_name": "ArraySlice", "params": [{"param_description": "Pass true to keep the existing capacity of the array after removing its elements. The default value is false.", "param_type": "Bool", "param_name": ["keepingCapacity", "keepCapacity"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": [""]}, "method_description": "Removes all the elements that satisfy the given predicate.", "method_name": "removeAll", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": [""]}, "method_description": "Removes all the elements that satisfy the given predicate.", "method_name": "removeAll", "class_name": "ArraySlice", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.", "param_type": "(Element", "param_name": ["where", "predicate"]}]}, {"return_value": {"return_description": ["The first element of the collection."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The first element of the collection."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the last element of the collection.", "method_name": "removeLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the last element of the collection.", "method_name": "removeLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["Element"]}, "method_description": "Removes and returns the last element of the collection.", "method_name": "removeLast", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the given number of elements from the end of the collection.", "method_name": "removeLast", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the specified number of elements from the end of the collection.", "method_name": "removeLast", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the specified number of elements from the end of the collection.", "method_name": "removeLast", "class_name": "ArraySlice", "params": [{"param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the elements in the specified subrange from the collection.", "method_name": "removeSubrange", "class_name": "ArraySlice", "params": [{"param_description": "The range of the collection to be removed. The bounds of the range must be valid indices of the collection.", "param_type": "Range<Int>", "param_name": ["bounds"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes the elements in the specified subrange from the collection.", "method_name": "removeSubrange", "class_name": "ArraySlice", "params": [{"param_description": "The range of the collection to be removed. The bounds of the range must be valid indices of the collection.", "param_type": "RangeExpression", "param_name": ["bounds"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Replaces a range of elements with the elements in the specified collection.", "method_name": "replaceSubrange", "class_name": "ArraySlice", "params": [{"param_description": "The subrange of the array to replace. The start and end of a subrange must be valid indices of the array.", "param_type": "Range<Int>", "param_name": ["subrange"]}, {"param_description": "The new elements to add to the array.", "param_type": "Collection", "param_name": ["with", "newElements"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Replaces the specified subrange of elements with the given collection.", "method_name": "R>", "class_name": "ArraySlice", "params": [{"param_description": "The subrange of the collection to replace. The bounds of the range must be valid indices of the collection.", "param_type": "RangeExpression", "param_name": ["subrange"]}, {"param_description": "The new elements to add to the collection.", "param_type": "Collection", "param_name": ["with", "newElements"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Reserves enough space to store the specified number of elements.", "method_name": "reserveCapacity", "class_name": "ArraySlice", "params": [{"param_description": "The requested number of elements to store.", "param_type": "Int", "param_name": ["minimumCapacity"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Prepares the collection to store the specified number of elements, when doing so is appropriate for the underlying type.", "method_name": "reserveCapacity", "class_name": "ArraySlice", "params": [{"param_description": "The requested number of elements to store.", "param_type": "Int", "param_name": ["n"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Reverses the elements of the collection in place.", "method_name": "reverse", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<ArraySlice<Element>>"]}, "method_description": "Returns a view presenting the elements of the collection in reverse order.", "method_name": "reversed", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Shuffles the collection in place.", "method_name": "shuffle", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Shuffles the collection in place, using the given generator as a source for randomness.", "method_name": "shuffle", "class_name": "ArraySlice", "params": [{"param_description": "The random number generator to use when shuffling the collection.", "param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"]}]}, {"return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element]"]}, "method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Element]"]}, "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "class_name": "ArraySlice", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Sorts the collection in place.", "method_name": "sort", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows"]}, "method_description": "Sorts the collection in place, using the given predicate as the comparison between elements.", "method_name": "sort", "class_name": "ArraySlice", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.", "param_type": "(Element", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element]"]}, "method_description": "Returns the elements of the sequence, sorted.", "method_name": "sorted", "class_name": "ArraySlice", "params": []}, {"return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["Bool rethrows -> [Element]"]}, "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "class_name": "ArraySlice", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Element", "param_name": ["Element"]}]}, {"return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "class_name": "ArraySlice", "params": [{"param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_type": "Int", "param_name": ["maxSplits"]}, {"param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_type": "Bool", "param_name": ["omittingEmptySubsequences"]}, {"param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_type": "(Element", "param_name": ["whereSeparator", "isSeparator"]}]}, {"return_value": {"return_description": ["An array of subsequences, split from this sequence\u2019s elements."], "return_name": [""], "return_type": ["[ArraySlice<Element>]"]}, "method_description": "Returns the longest possible subsequences of the sequence, in order, around elements equal to the given element.", "method_name": "split", "class_name": "ArraySlice", "params": [{"param_description": "The element that should be split upon.", "param_type": "Element", "param_name": ["separator"]}, {"param_description": "The maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_type": "Int", "param_name": ["maxSplits"]}, {"param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.", "param_type": "Bool", "param_name": ["omittingEmptySubsequences"]}]}, {"return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[ArraySlice<Element>]"]}, "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "method_name": "split", "class_name": "ArraySlice", "params": [{"param_description": "The element that should be split upon.", "param_type": "Element", "param_name": ["separator"]}, {"param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_type": "Int", "param_name": ["maxSplits"]}, {"param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.", "param_type": "Bool", "param_name": ["omittingEmptySubsequences"]}]}, {"return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "method_name": "starts", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}]}, {"return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "class_name": "ArraySlice", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(Element", "param_name": ["by", "areEquivalent"]}, {"param_description": "", "param_type": "Sequence.Element", "param_name": ["Sequence.Element"]}]}, {"return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "class_name": "ArraySlice", "params": [{"param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_type": "Int", "param_name": ["maxLength"]}]}, {"return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "class_name": "ArraySlice", "params": [{"param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_type": "Int", "param_name": ["from", "start"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Exchanges the values at the specified indices of the collection.", "method_name": "swapAt", "class_name": "ArraySlice", "params": [{"param_description": "The index of the first value to swap.", "param_type": "Int", "param_name": ["i"]}, {"param_description": "The index of the second value to swap.", "param_type": "Int", "param_name": ["j"]}]}, {"return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R rethrows -> R"]}, "method_description": "Calls a closure with a pointer to the array\u2019s contiguous storage.", "method_name": "withUnsafeBufferPointer", "class_name": "ArraySlice", "params": [{"param_description": "A closure with an UnsafeBufferPointer parameter that points to the contiguous storage for the array.  If body has a return value, that value is also used as the return value for the withUnsafeBufferPointer(_:) method. The pointer argument is valid only for the duration of the method\u2019s execution.", "param_type": "(UnsafeBufferPointer<ArraySlice<Element>.Element>", "param_name": ["body"]}]}, {"return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R rethrows -> R"]}, "method_description": "Calls the given closure with a pointer to the underlying bytes of the array\u2019s contiguous storage.", "method_name": "withUnsafeBytes", "class_name": "ArraySlice", "params": [{"param_description": "A closure with an UnsafeRawBufferPointer parameter that points to the contiguous storage for the array. If no such storage exists, it is created. If body has a return value, that value is also used as the return value for the withUnsafeBytes(_:) method. The argument is valid only for the duration of the closure\u2019s execution.", "param_type": "(UnsafeRawBufferPointer", "param_name": ["body"]}]}, {"return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R rethrows -> R"]}, "method_description": "Calls the given closure with a pointer to the array\u2019s mutable contiguous storage.", "method_name": "withUnsafeMutableBufferPointer", "class_name": "ArraySlice", "params": [{"param_description": "A closure with an UnsafeMutableBufferPointer parameter that points to the contiguous storage for the array. If body has a return value, that value is also used as the return value for the withUnsafeMutableBufferPointer(_:) method. The pointer argument is valid only for the duration of the method\u2019s execution.", "param_type": "(inout UnsafeMutableBufferPointer<ArraySlice<Element>.Element>", "param_name": ["body"]}]}, {"return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R rethrows -> R"]}, "method_description": "Calls the given closure with a pointer to the underlying bytes of the array\u2019s mutable contiguous storage.", "method_name": "withUnsafeMutableBytes", "class_name": "ArraySlice", "params": [{"param_description": "A closure with an UnsafeMutableRawBufferPointer parameter that points to the contiguous storage for the array. If no such storage exists, it is created. If body has a return value, that value is also used as the return value for the withUnsafeMutableBytes(_:) method. The argument is valid only for the duration of the closure\u2019s execution.", "param_type": "(UnsafeMutableRawBufferPointer", "param_name": ["body"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two arrays are not equal.", "method_name": "!=", "class_name": "ArraySlice", "params": [{"param_description": "An array to compare.", "param_type": "ArraySlice<ArraySlice<Element>.Element>", "param_name": ["lhs"]}, {"param_description": "Another array to compare.", "param_type": "ArraySlice<ArraySlice<Element>.Element>", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "class_name": "ArraySlice", "params": [{"param_description": "A value to compare.", "param_type": "ArraySlice<Element>", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "ArraySlice<Element>", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Creates a new collection by concatenating the elements of a sequence and a collection.", "method_name": "", "class_name": "ArraySlice", "params": [{"param_description": "A collection or finite sequence.", "param_type": "Sequence", "param_name": ["lhs"]}, {"param_description": "A range-replaceable collection.", "param_type": "ArraySlice<Element>", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Creates a new collection by concatenating the elements of a collection and a sequence.", "method_name": "", "class_name": "ArraySlice", "params": [{"param_description": "A range-replaceable collection.", "param_type": "ArraySlice<Element>", "param_name": ["lhs"]}, {"param_description": "A collection or finite sequence.", "param_type": "Sequence", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "method_description": "Creates a new collection by concatenating the elements of two collections.", "method_name": "", "class_name": "ArraySlice", "params": [{"param_description": "A range-replaceable collection.", "param_type": "ArraySlice<Element>", "param_name": ["lhs"]}, {"param_description": "Another range-replaceable collection.", "param_type": "RangeReplaceableCollection", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Appends the elements of a sequence to a range-replaceable collection.", "method_name": "", "class_name": "ArraySlice", "params": [{"param_description": "The array to append to.", "param_type": "inout ArraySlice<Element>", "param_name": ["lhs"]}, {"param_description": "A collection or finite sequence.", "param_type": "Sequence", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two arrays contain the same elements in the same order.", "method_name": "==", "class_name": "ArraySlice", "params": [{"param_description": "An array to compare.", "param_type": "ArraySlice<ArraySlice<Element>.Element>", "param_name": ["lhs"]}, {"param_description": "Another array to compare.", "param_type": "ArraySlice<ArraySlice<Element>.Element>", "param_name": ["rhs"]}]}], "package_name": "swift"}