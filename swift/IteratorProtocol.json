{"class_description": "The IteratorProtocol protocol is tightly linked with the Sequence protocol. Sequences provide access to their elements by creating an iterator, which keeps track of its iteration process and returns one element at a time as it advances through the sequence.\nWhenever you use a for-in loop with an array, set, or any other collection or sequence, you\u2019re using that type\u2019s iterator. Swift uses a sequence\u2019s or collection\u2019s iterator internally to enable the for-in loop language construct.\nUsing a sequence\u2019s iterator directly gives you access to the same elements in the same order as iterating over that sequence using a for-in loop. For example, you might typically use a for-in loop to print each of the elements in an array.\nBehind the scenes, Swift uses the animals array\u2019s iterator to loop over the contents of the array.\nThe call to animals.makeIterator() returns an instance of the array\u2019s iterator. Next, the while loop calls the iterator\u2019s next() method repeatedly, binding each element that is returned to animal and exiting when the next() method returns nil.\nYou rarely need to use iterators directly, because a for-in loop is the more idiomatic approach to traversing a sequence in Swift. Some algorithms, however, may call for direct iterator use.\nOne example is the reduce1(_:) method. Similar to the reduce(_:_:) method defined in the standard library, which takes an initial value and a combining closure, reduce1(_:) uses the first element of the sequence as the initial value.\nHere\u2019s an implementation of the reduce1(_:) method. The sequence\u2019s iterator is used directly to retrieve the initial value before looping over the rest of the sequence.\nThe reduce1(_:) method makes certain kinds of sequence operations simpler. Here\u2019s how to find the longest string in a sequence, using the animals array introduced earlier as an example:\nWhenever you use multiple iterators (or for-in loops) over a single sequence, be sure you know that the specific sequence supports repeated iteration, either because you know its concrete type or because the sequence is also constrained to the Collection protocol.\nObtain each separate iterator from separate calls to the sequence\u2019s makeIterator() method rather than by copying. Copying an iterator is safe, but advancing one copy of an iterator by calling its next() method may invalidate other copies of that iterator. for-in loops are safe in this regard.\nImplementing an iterator that conforms to IteratorProtocol is simple. Declare a next() method that advances one step in the related sequence and returns the current element. When the sequence has been exhausted, the next() method returns nil.\nFor example, consider a custom Countdown sequence. You can initialize the Countdown sequence with a starting integer and then iterate over the count down to zero. The Countdown structure\u2019s definition is short: It contains only the starting count and the makeIterator() method required by the Sequence protocol.\nThe makeIterator() method returns another custom type, an iterator named CountdownIterator. The CountdownIterator type keeps track of both the Countdown sequence that it\u2019s iterating and the number of times it has returned a value.\nEach time the next() method is called on a CountdownIterator instance, it calculates the new next value, checks to see whether it has reached zero, and then returns either the number, or nil if the iterator is finished returning elements of the sequence.\nCreating and iterating over a Countdown sequence uses a CountdownIterator to handle the iteration.\n", "package_name": "swift", "interface_list": [], "Methods": [{"return_value": {"return_name": [""], "return_description": ["The next element in the underlying sequence, if a next element exists; otherwise, nil."], "return_type": ["Self.Element"]}, "class_name": "IteratorProtocol", "method_description": "Advances to the next element and returns it, or nil if no next element exists.Required.", "method_name": "next", "params": []}], "class_inherit_list": [], "Vars": [], "subclass_list": [], "class_name": "IteratorProtocol"}