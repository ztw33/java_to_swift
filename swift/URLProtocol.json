{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the registration is successful, false otherwise. The only failure condition is if protocolClass is not a subclass of URLProtocol."]}, "method_name": "registerClass", "class_name": "URLProtocol", "method_description": "Attempts to register a subclass of URLProtocol, making it visible to the URL loading system.", "params": [{"param_type": "AnyClass", "param_name": ["protocolClass"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "unregisterClass", "class_name": "URLProtocol", "method_description": "Unregisters the specified subclass of URLProtocol.", "params": [{"param_type": "AnyClass", "param_name": ["protocolClass"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the protocol subclass can handle request, otherwise false."]}, "method_name": "canInit", "class_name": "URLProtocol", "method_description": "Determines whether the protocol subclass can handle the specified request.", "params": [{"param_type": "URLRequest", "param_name": ["with", "request"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": []}, "method_name": "canInit", "class_name": "URLProtocol", "method_description": "Determines whether the protocol subclass can handle the specified task.", "params": [{"param_type": "URLSessionTask", "param_name": ["with", "task"], "param_description": ""}]}, {"return_value": {"return_type": ["Any"], "return_name": [""], "return_description": ["The property associated with key, or nil if no property has been stored for key."]}, "method_name": "property", "class_name": "URLProtocol", "method_description": "Fetches the property associated with the specified key in the specified request.", "params": [{"param_type": "String", "param_name": ["forKey", "key"], "param_description": ""}, {"param_type": "URLRequest", "param_name": ["in", "request"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "setProperty", "class_name": "URLProtocol", "method_description": "Sets the property associated with the specified key in the specified request.", "params": [{"param_type": "Any", "param_name": ["value"], "param_description": ""}, {"param_type": "String", "param_name": ["forKey", "key"], "param_description": ""}, {"param_type": "NSMutableURLRequest", "param_name": ["in", "request"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "removeProperty", "class_name": "URLProtocol", "method_description": "Removes the property associated with the specified key in the specified request.", "params": [{"param_type": "String", "param_name": ["forKey", "key"], "param_description": ""}, {"param_type": "NSMutableURLRequest", "param_name": ["in", "request"], "param_description": ""}]}, {"return_value": {"return_type": ["URLRequest"], "return_name": [""], "return_description": ["The canonical form of request."]}, "method_name": "canonicalRequest", "class_name": "URLProtocol", "method_description": "Returns a canonical version of the specified request.", "params": [{"param_type": "URLRequest", "param_name": ["for", "request"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if aRequest and bRequest are equivalent for cache purposes, false otherwise. "]}, "method_name": "requestIsCacheEquivalent", "class_name": "URLProtocol", "method_description": "A Boolean value indicating whether two requests are equivalent for cache purposes.", "params": [{"param_type": "URLRequest", "param_name": ["a"], "param_description": ""}, {"param_type": "URLRequest", "param_name": ["to", "b"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "startLoading", "class_name": "URLProtocol", "method_description": "Starts protocol-specific loading of the request.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "stopLoading", "class_name": "URLProtocol", "method_description": "Stops protocol-specific loading of the request.", "params": []}], "Vars": [{"var_type": "CachedURLResponse", "var_description": "The protocol\u2019s cached response.", "var_name": "cachedResponse"}, {"var_type": "URLProtocolClient", "var_description": "The object the protocol uses to communicate with the URL loading system.", "var_name": "client"}, {"var_type": "URLRequest", "var_description": "The protocol\u2019s request.", "var_name": "request"}, {"var_type": "URLSessionTask", "var_description": "The protocol\u2019s task.", "var_name": "task"}], "subclass_list": [], "class_description": "Don\u2019t instantiate a URLProtocol subclass directly. Instead, create subclasses for any custom protocols or URL schemes that your app supports. When a download starts, the system creates the appropriate protocol object to handle the corresponding URL request. You define your protocol class and call the registerClass(_:) class method during your app\u2019s launch time so that the system is aware of your protocol.\nNote\nYou cannot use this class to define custom URL schemes and protocols in watchOS 2 and later.\nTo support the customization of protocol-specific requests, create extensions to the URLRequest class to provide any custom API that you need. You can store and retrieve protocol-specific request data by using URLProtocol\u2019s class methods property(forKey:in:) and setProperty(_:forKey:in:).\nCreate a URLResponse for each request your subclass processes successfully. You may want to create a custom URLResponse class to provide protocol specific information.\n\nWhen overriding methods of this class, be aware that methods that take a task parameter are preferred by the system to those that do not. Therefore, you should override the task-based methods when subclassing, as follows:\nInitialization \u2014 Override init(task:cachedResponse:client:) instead of or in addition to init(request:cachedResponse:client:). Also override the task-based canInit(with:) instead of or in addition to the request-based canInit(with:).\n\n", "class_name": "URLProtocol"}