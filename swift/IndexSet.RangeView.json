{"subclass_list": [], "Methods": [{"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "IndexSet.RangeView.Index"}], "method_name": "index", "method_description": "Returns the index in the range after the specified one.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView.Index"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "IndexSet.RangeView.Index"}], "method_name": "index", "method_description": "Returns the index in the range before the specified one.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView.Index"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["through", "position"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection through the specified position.", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["upTo", "end"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "suffix", "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "Int"}], "method_name": "suffix", "method_description": "Returns a subsequence from the specified position to the end of the collection.", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the first element of the sequence.", "return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the given number of initial elements.", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the last element of the sequence.", "return_value": {"return_description": ["A subsequence leaving off the last element of the sequence."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the specified number of final elements.", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "enumerated", "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "makeIterator", "method_description": "Returns an iterator over the indexes of this range view.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "reversed", "method_description": "Returns a view presenting the elements of the collection in reverse order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["separator"], "param_description": "", "param_type": "Range<IndexSet.Element>"}, {"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[Slice<IndexSet.RangeView>]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["separator"], "param_description": "", "param_type": "Sequence"}], "method_name": "joined", "method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "return_value": {"return_description": ["The joined sequence of elements."], "return_name": [""], "return_type": ["JoinedSequence<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "joined", "method_description": "Returns the elements of this collection of collections, concatenated.", "return_value": {"return_description": ["A flattened view of the elements of this collection of collections."], "return_name": [""], "return_type": ["FlattenCollection<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["element"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "contains", "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "return_value": {"return_description": ["true if the element was found in the sequence; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the first element of the sequence.", "return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the given number of initial elements.", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the last element of the sequence.", "return_value": {"return_description": ["A subsequence leaving off the last element of the sequence."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the specified number of final elements.", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "enumerated", "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "IndexSet.RangeView.Index"}], "method_name": "index", "method_description": "Returns the index in the range after the specified one.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView.Index"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "IndexSet.RangeView.Index"}], "method_name": "index", "method_description": "Returns the index in the range before the specified one.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView.Index"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "joined", "method_description": "Returns the elements of this collection of collections, concatenated.", "return_value": {"return_description": ["A flattened view of the elements of this collection of collections."], "return_name": [""], "return_type": ["FlattenCollection<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["separator"], "param_description": "", "param_type": "Sequence"}], "method_name": "joined", "method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "return_value": {"return_description": ["The joined sequence of elements."], "return_name": [""], "return_type": ["JoinedSequence<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "makeIterator", "method_description": "Returns an iterator over the indexes of this range view.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["through", "position"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection through the specified position.", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["upTo", "end"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "reversed", "method_description": "Returns a view presenting the elements of the collection in reverse order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["separator"], "param_description": "", "param_type": "Range<IndexSet.Element>"}, {"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[Slice<IndexSet.RangeView>]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "suffix", "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "Int"}], "method_name": "suffix", "method_description": "Returns a subsequence from the specified position to the end of the collection.", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexSet.RangeView"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexSet.RangeView"}], "method_name": "!=", "method_description": "Returns a Boolean value indicating whether two values are not equal.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexSet.RangeView"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexSet.RangeView"}], "method_name": "==", "method_description": "Indicates whether two range views are the same.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "allSatisfy", "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "compactMap", "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "contains", "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "Int"}, {"param_name": ["to", "end"], "param_description": "", "param_type": "Int"}], "method_name": "distance", "method_description": "Returns the distance between two indices.", "return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["while", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "drop", "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areEquivalent"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}, {"param_name": ["Sequence.Element"], "param_description": "", "param_type": "Sequence.Element"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["isIncluded"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "filter", "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "return_value": {"return_description": ["An array of the elements that isIncluded allowed."], "return_name": [""], "return_type": ["Bool rethrows -> [Range<IndexSet.Element>]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "first", "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["of", "element"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "firstIndex", "method_description": "Returns the first index where the specified value appears in the collection.", "return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "firstIndex", "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "flatMap", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["String rethrows -> [String]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["body"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "forEach", "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "inout Int"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}], "method_name": "formIndex", "method_description": "Offsets the given index by the specified distance.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "inout Int"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}, {"param_name": ["limitedBy", "limit"], "param_description": "", "param_type": "Int"}], "method_name": "formIndex", "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "inout Int"}], "method_name": "formIndex", "method_description": "Replaces the given index with its successor.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "inout Int"}], "method_name": "formIndex", "method_description": "Replaces the given index with its predecessor.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "Int"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}], "method_name": "index", "method_description": "Returns an index that is the specified distance from the given index.", "return_value": {"return_description": ["An index offset by n from the index i. If n is positive, this is the same value as the result of n calls to index(after:). If n is negative, this is the same value as the result of -n calls to index(before:)."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "Int"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}, {"param_name": ["limitedBy", "limit"], "param_description": "", "param_type": "Int"}], "method_name": "index", "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "return_value": {"return_description": ["An index offset by n from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "last", "method_description": "Returns the last element of the sequence that satisfies the given predicate.", "return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["of", "element"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "lastIndex", "method_description": "Returns the last index where the specified value appears in the collection.", "return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "lastIndex", "method_description": "Returns the index of the last element in the collection that matches the given predicate.", "return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}, {"param_name": ["Range<IndexSet.Element>"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "lexicographicallyPrecedes", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "map", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "map", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}, {"param_name": ["Range<IndexSet.Element>"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "max", "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Bool rethrows -> Range<IndexSet.Element>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}, {"param_name": ["Range<IndexSet.Element>"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "min", "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Bool rethrows -> Range<IndexSet.Element>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["while", "predicate"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "prefix", "method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> Slice<IndexSet.RangeView>"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "randomElement", "method_description": "Returns a random element of the collection.", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Range<IndexSet.Element>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "randomElement", "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Range<IndexSet.Element>"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["initialResult"], "param_description": "", "param_type": "Result"}, {"param_name": ["nextPartialResult"], "param_description": "", "param_type": "(Result"}, {"param_name": ["Range<IndexSet.Element>"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "reduce", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result rethrows -> Result"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["into", "initialResult"], "param_description": "", "param_type": "Result"}, {"param_name": ["updateAccumulatingResult"], "param_description": "", "param_type": "(inout Result"}, {"param_name": ["Range<IndexSet.Element>"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "reduce", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["rethrows -> Result"]}, "class_name": "IndexSet.RangeView"}, {"params": [], "method_name": "shuffled", "method_description": "Returns the elements of the sequence, shuffled.", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Range<IndexSet.Element>]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "shuffled", "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Range<IndexSet.Element>]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}, {"param_name": ["Range<IndexSet.Element>"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "sorted", "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["Bool rethrows -> [Range<IndexSet.Element>]"]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}, {"param_name": ["whereSeparator", "isSeparator"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet.RangeView"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areEquivalent"], "param_description": "", "param_type": "(Range<IndexSet.Element>"}, {"param_name": ["Sequence.Element"], "param_description": "", "param_type": "Sequence.Element"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet.RangeView"}], "Vars": [{"var_name": "count", "var_description": "The number of elements in the collection.", "var_type": "Int"}, {"var_name": "endIndex", "var_description": "The ending index in the range.", "var_type": "IndexSet.RangeView.Index"}, {"var_name": "first", "var_description": "The first element of the collection.", "var_type": "Range<IndexSet.Element>"}, {"var_name": "isEmpty", "var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool"}, {"var_name": "last", "var_description": "The last element of the collection.", "var_type": "Range<IndexSet.Element>"}, {"var_name": "lazy", "var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<IndexSet.RangeView>"}, {"var_name": "lazy", "var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<IndexSet.RangeView>"}, {"var_name": "startIndex", "var_description": "The beginning index in the range.", "var_type": "IndexSet.RangeView.Index"}, {"var_name": "startIndex", "var_description": "The beginning index in the range.", "var_type": "IndexSet.RangeView.Index"}, {"var_name": "endIndex", "var_description": "The ending index in the range.", "var_type": "IndexSet.RangeView.Index"}, {"var_name": "lazy", "var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<IndexSet.RangeView>"}, {"var_name": "lazy", "var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<IndexSet.RangeView>"}, {"var_name": "indices", "var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<IndexSet.RangeView>"}, {"var_name": "underestimatedCount", "var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "var_type": "Int"}, {"var_name": "underestimatedCount", "var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int"}], "class_name": "IndexSet.RangeView", "class_inherit_list": [], "interface_list": ["BidirectionalCollection", "Equatable"], "class_description": "For example, if an IndexSet is composed of: [1..<5] and [7..<10] and [13] then calling next() on this view\u2019s iterator will produce 3 ranges before returning nil.\n", "package_name": "foundation"}