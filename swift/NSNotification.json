{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable", "NSCoding", "NSCopying"], "class_inherit_list": ["NSObject"], "Methods": [], "Vars": [{"var_type": "NSNotification.Name", "var_description": "The name of the notification.", "var_name": "name"}, {"var_type": "Any", "var_description": "The object associated with the notification.", "var_name": "object"}, {"var_type": "[AnyHashable", "var_description": "The user information dictionary associated with the notification.", "var_name": "userInfo"}], "subclass_list": [], "class_description": "A notification contains a name, an object, and an optional dictionary, and is broadcast to by instances of  NotificationCenter or DistributedNotificationCenter. The name is a tag identifying the notification. The object is any object that the poster of the notification wants to send to observers of that notification (typically, the object posting the notification). The dictionary stores other related objects, if any. NSNotification objects are immutable.\nYou don\u2019t usually create your own notifications directly, but instead call the NotificationCenter methods post(name:object:) and post(name:object:userInfo:).\nImportant\nThe Swift overlay to the Foundation framework provides the Notification structure, which bridges to the NSNotification class. For more information about value types, see Working with Cocoa Frameworks in Using Swift with Cocoa and Objective-C (Swift 4.1).\n\nThe objects of a notification are compared using pointer equality for local notifications. Distributed notifications use strings as their objects, and those strings are compared using isEqual(_:), because pointer equality doesn\u2019t make sense across process boundaries.\nYou can subclass NSNotification to contain information in addition to the notification name, object, and dictionary. This extra data must be agreed upon between notifiers and observers.\nNotificationCenter is a class cluster with no instance variables. As such, you must subclass NSNotification and override the primitive methods name, object, and userInfo. You can choose any designated initializer you like, but be sure that your initializer does not call init() on super (NSNotification is not meant to be instantiated directly, and its init method raises an exception).\n", "class_name": "NSNotification"}