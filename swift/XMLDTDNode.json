{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["XMLNode"], "Methods": [], "Vars": [{"var_type": "XMLDTDNode.DTDKind", "var_description": "Returns the receiver\u2019s DTD kind.", "var_name": "dtdKind"}, {"var_type": "String", "var_description": "Returns the name of the notation associated with the receiver.", "var_name": "notationName"}, {"var_type": "String", "var_description": "Returns the public identifier associated with the receiver.", "var_name": "publicID"}, {"var_type": "String", "var_description": "Returns the system identifier associated with the receiver.", "var_name": "systemID"}, {"var_type": "Bool", "var_description": "", "var_name": "isExternal"}], "subclass_list": [], "class_description": "XMLDTDNode objects are the sole children of a XMLDTD object (possibly along with comment nodes and processing-instruction nodes). They themselves cannot have any children.\nXMLDTDNode objects can be of four kinds\u2014element, attribute-list, entity, or notation declaration\u2014and can also be of a subkind, as specified by a XMLDTDNode.DTDKind constant. For example, a DTD entity-declaration node could represent an unparsed entity declaration (XMLDTDNode.DTDKind.unparsed) rather than a parameter entity declaration (XMLDTDNode.DTDKind.parameter). You can use a DTD node\u2019s subkind to help determine how to handle the value of the node.\nYou can create an XMLDTDNode object with the init(xmlString:) method, the XMLNode class method dtdNode(withXMLString:), or with the XMLNode initializer init(kind:options:) (in the latter method supplying the appropriate XMLNode.Kind constant).\nSetting the object value or string value of an XMLDTDNode objects affects different parts of different kinds of declaration. See the related programming topic for more information.\n", "class_name": "XMLDTDNode"}