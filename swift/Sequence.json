{"class_description": "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a for-in loop:\nWhile seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you\u2019ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.\nThe Sequence protocol provides default implementations for many common operations that depend on sequential access to a sequence\u2019s values. For clearer, more concise code, the example above could use the array\u2019s contains(_:) method, which every sequence inherits from Sequence, instead of iterating manually:\nThe Sequence protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don\u2019t assume that multiple for-in loops on a sequence will either resume iteration or restart from the beginning:\nIn this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second for-in loop.\nTo establish that a type you\u2019ve created supports nondestructive iteration, add conformance to the Collection protocol.\nMaking your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.\nAlternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.\nHere\u2019s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.\nA sequence should provide its iterator in O(1). The Sequence protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(n) unless documented otherwise.\n", "package_name": "swift", "interface_list": [], "Methods": [{"return_value": {"return_name": [""], "return_description": [], "return_type": ["Self.Iterator"]}, "class_name": "Sequence", "method_description": "Returns an iterator over the elements of this sequence.Required. Default implementation provided.", "method_name": "makeIterator", "params": []}, {"return_value": {"return_name": [""], "return_description": ["true if the element was found in the sequence; otherwise, false."], "return_type": ["Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "method_name": "contains", "params": [{"param_type": "Self.Element", "param_name": ["element"], "param_description": "The element to find in the sequence."}]}, {"return_value": {"return_name": [""], "return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_type": [""]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "params": [{"param_type": "(Self.Element", "param_name": ["where", "predicate"], "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match."}]}, {"return_value": {"return_name": [""], "return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_type": [""]}, "class_name": "Sequence", "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "params": [{"param_type": "(Self.Element", "param_name": ["where", "predicate"], "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match."}]}, {"return_value": {"return_name": [""], "return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_type": ["Self.Element"]}, "class_name": "Sequence", "method_description": "Returns the minimum element in the sequence.", "method_name": "min", "params": []}, {"return_value": {"return_name": [""], "return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_type": ["Bool rethrows -> Self.Element"]}, "class_name": "Sequence", "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "params": [{"param_type": "(Self.Element", "param_name": ["by", "areInIncreasingOrder"], "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false."}, {"param_type": "Self.Element", "param_name": ["Self.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_type": ["Self.Element"]}, "class_name": "Sequence", "method_description": "Returns the maximum element in the sequence.", "method_name": "max", "params": []}, {"return_value": {"return_name": [""], "return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_type": ["Bool rethrows -> Self.Element"]}, "class_name": "Sequence", "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "params": [{"param_type": "(Self.Element", "param_name": ["by", "areInIncreasingOrder"], "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false."}, {"param_type": "Self.Element", "param_name": ["Self.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence starting after the first element of the sequence."], "return_type": ["Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence containing all but the first element of the sequence.", "method_name": "dropFirst", "params": []}, {"return_value": {"return_name": [""], "return_description": ["A subsequence leaving off the last element of the sequence."], "return_type": ["Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence containing all but the last element of the sequence.", "method_name": "dropLast", "params": []}, {"return_value": {"return_name": [""], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "class_name": "Sequence", "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "params": [{"param_type": "(Self.Element", "param_name": ["transform"], "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value."}]}, {"return_value": {"return_name": [""], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "class_name": "Sequence", "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "flatMap", "params": [{"param_type": "(Self.Element", "param_name": ["transform"], "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value."}]}, {"return_value": {"return_name": [""], "return_description": ["The resulting flattened array."], "return_type": ["SegmentOfResult rethrows -> [SegmentOfResult.Element]"]}, "class_name": "Sequence", "method_description": "Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.", "method_name": "flatMap", "params": [{"param_type": "(Self.Element", "param_name": ["transform"], "param_description": "A closure that accepts an element of this sequence as its argument and returns a sequence or collection."}]}, {"return_value": {"return_name": [""], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_type": ["Result rethrows -> Result"]}, "class_name": "Sequence", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_name": ["initialResult"], "param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed."}, {"param_type": "(Result", "param_name": ["nextPartialResult"], "param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller."}, {"param_type": "Self.Element", "param_name": ["Self.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_type": ["rethrows -> Result"]}, "class_name": "Sequence", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_name": ["into", "initialResult"], "param_description": "The value to use as the initial accumulating value."}, {"param_type": "(inout Result", "param_name": ["updateAccumulatingResult"], "param_description": "A closure that updates the accumulating value with an element of the sequence."}, {"param_type": "Self.Element", "param_name": ["Self.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["A sequence of pairs enumerating the sequence."], "return_type": ["EnumeratedSequence<Self>"]}, "class_name": "Sequence", "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "params": []}, {"return_value": {"return_name": [""], "return_description": ["A sorted array of the sequence\u2019s elements."], "return_type": ["[Self.Element]"]}, "class_name": "Sequence", "method_description": "Returns the elements of the sequence, sorted.", "method_name": "sorted", "params": []}, {"return_value": {"return_name": [""], "return_description": ["A sorted array of the sequence\u2019s elements."], "return_type": ["Bool rethrows -> [Self.Element]"]}, "class_name": "Sequence", "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "params": [{"param_type": "(Self.Element", "param_name": ["by", "areInIncreasingOrder"], "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false."}, {"param_type": "Self.Element", "param_name": ["Self.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["An array containing the elements of this sequence in reverse order."], "return_type": ["[Self.Element]"]}, "class_name": "Sequence", "method_description": "Returns an array containing the elements of this sequence in reverse order.", "method_name": "reversed", "params": []}, {"return_value": {"return_name": [""], "return_description": ["An array of subsequences, split from this sequence\u2019s elements."], "return_type": ["[Self.SubSequence]"]}, "class_name": "Sequence", "method_description": "Returns the longest possible subsequences of the sequence, in order, around elements equal to the given element.", "method_name": "split", "params": [{"param_type": "Self.Element", "param_name": ["separator"], "param_description": "The element that should be split upon."}, {"param_type": "Int", "param_name": ["maxSplits"], "param_description": "The maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max."}, {"param_type": "Bool", "param_name": ["omittingEmptySubsequences"], "param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true."}]}, {"return_value": {"return_name": [""], "return_description": ["A flattened view of the elements of this sequence of sequences."], "return_type": ["FlattenSequence<Self>"]}, "class_name": "Sequence", "method_description": "Returns the elements of this sequence of sequences, concatenated.", "method_name": "joined", "params": []}, {"return_value": {"return_name": [""], "return_description": ["A single, concatenated string."], "return_type": ["String"]}, "class_name": "Sequence", "method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "method_name": "joined", "params": [{"param_type": "String", "param_name": ["separator"], "param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string."}]}, {"return_value": {"return_name": [""], "return_description": ["The joined sequence of elements."], "return_type": ["JoinedSequence<Self>"]}, "class_name": "Sequence", "method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "method_name": "joined", "params": [{"param_type": "Sequence", "param_name": ["separator"], "param_description": "A sequence to insert between each of this sequence\u2019s elements."}]}, {"return_value": {"return_name": [""], "return_description": ["true if this sequence and other contain the same elements in the same order."], "return_type": ["Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_name": ["other"], "param_description": "A sequence to compare to this sequence."}]}, {"return_value": {"return_name": [""], "return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_name": ["other"], "param_description": "A sequence to compare to this sequence."}, {"param_type": "(Self.Element", "param_name": ["by", "areEquivalent"], "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false."}, {"param_type": "Sequence.Element", "param_name": ["Sequence.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_type": ["Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_name": ["with", "possiblePrefix"], "param_description": "A sequence to compare to this sequence."}]}, {"return_value": {"return_name": [""], "return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_type": ["Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_name": ["other"], "param_description": "A sequence to compare to this sequence."}]}, {"return_value": {"return_name": [""], "return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_name": ["other"], "param_description": "A sequence to compare to this sequence."}, {"param_type": "(Self.Element", "param_name": ["by", "areInIncreasingOrder"], "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false."}, {"param_type": "Self.Element", "param_name": ["Self.Element"], "param_description": ""}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Sequence", "method_description": "", "method_name": "clip", "params": []}, {"return_value": {"return_name": [""], "return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "params": [{"param_type": "(Self.Element", "param_name": ["predicate"], "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition."}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Bool rethrows -> Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.Required. Default implementations provided.", "method_name": "drop", "params": [{"param_type": "(Self.Element", "param_name": ["while", "predicate"], "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match."}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence starting after the specified number of elements."], "return_type": ["Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence containing all but the given number of initial elements.Required. Default implementations provided.", "method_name": "dropFirst", "params": [{"param_type": "Int", "param_name": ["k"], "param_description": "The number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero."}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence leaving off the specified number of elements."], "return_type": ["Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence containing all but the specified number of final elements.Required. Default implementations provided.", "method_name": "dropLast", "params": [{"param_type": "Int", "param_name": ["k"], "param_description": "The number of elements to drop off the end of the sequence. k must be greater than or equal to zero."}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Sequence", "method_description": "", "method_name": "fill", "params": [{"param_type": "NSCompositingOperation", "param_name": ["using", "operation"], "param_description": ""}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Sequence", "method_description": "", "method_name": "fill", "params": [{"param_type": "NSCompositingOperation", "param_name": ["using", "operation"], "param_description": ""}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "class_name": "Sequence", "method_description": "", "method_name": "fill", "params": [{"param_type": "NSCompositingOperation", "param_name": ["using", "operation"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["An array of the elements that isIncluded allowed."], "return_type": ["Bool rethrows -> [Self.Element]"]}, "class_name": "Sequence", "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.Required. Default implementations provided.", "method_name": "filter", "params": [{"param_type": "(Self.Element", "param_name": ["isIncluded"], "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array."}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void rethrows"]}, "class_name": "Sequence", "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.Required. Default implementation provided.", "method_name": "forEach", "params": [{"param_type": "(Self.Element", "param_name": ["body"], "param_description": "A closure that takes an element of the sequence as a parameter."}]}, {"return_value": {"return_name": [""], "return_description": ["An array containing the transformed elements of this sequence."], "return_type": ["T rethrows -> [T]"]}, "class_name": "Sequence", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.Required. Default implementations provided.", "method_name": "map", "params": [{"param_type": "(Self.Element", "param_name": ["transform"], "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type."}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence starting at the beginning of this sequence with at most maxLength elements."], "return_type": ["Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the sequence.Required. Default implementations provided.", "method_name": "prefix", "params": [{"param_type": "Int", "param_name": ["maxLength"], "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero."}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence of the initial, consecutive elements that satisfy predicate."], "return_type": ["Bool rethrows -> Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence containing the initial, consecutive elements that satisfy the given predicate.Required. Default implementations provided.", "method_name": "prefix", "params": [{"param_type": "(Self.Element", "param_name": ["while", "predicate"], "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result."}]}, {"return_value": {"return_name": [""], "return_description": ["A shuffled array of this sequence\u2019s elements."], "return_type": ["[Self.Element]"]}, "class_name": "Sequence", "method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "params": []}, {"return_value": {"return_name": [""], "return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_type": ["[Self.Element]"]}, "class_name": "Sequence", "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "params": [{"param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"], "param_description": "The random number generator to use when shuffling the sequence."}]}, {"return_value": {"return_name": [""], "return_description": ["An array of subsequences, split from this sequence\u2019s elements."], "return_type": [""]}, "class_name": "Sequence", "method_description": "Returns the longest possible subsequences of the sequence, in order, that don\u2019t contain elements satisfying the given predicate.Required. Default implementations provided.", "method_name": "split", "params": [{"param_type": "Int", "param_name": ["maxSplits"], "param_description": "The maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max."}, {"param_type": "Bool", "param_name": ["omittingEmptySubsequences"], "param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true."}, {"param_type": "(Self.Element", "param_name": ["whereSeparator", "isSeparator"], "param_description": "A closure that returns true if its argument should be used to split the sequence; otherwise, false."}]}, {"return_value": {"return_name": [""], "return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "Sequence", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_name": ["with", "possiblePrefix"], "param_description": "A sequence to compare to this sequence."}, {"param_type": "(Self.Element", "param_name": ["by", "areEquivalent"], "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false."}, {"param_type": "Sequence.Element", "param_name": ["Sequence.Element"], "param_description": ""}]}, {"return_value": {"return_name": [""], "return_description": ["A subsequence terminating at the end of this sequence with at most maxLength elements."], "return_type": ["Self.SubSequence"]}, "class_name": "Sequence", "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the sequence.Required. Default implementations provided.", "method_name": "suffix", "params": [{"param_type": "Int", "param_name": ["maxLength"], "param_description": "The maximum number of elements to return. The value of maxLength must be greater than or equal to zero."}]}], "class_inherit_list": [], "Vars": [{"var_type": "LazySequence<Self>", "var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_name": "lazy"}, {"var_type": "Int", "var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.Required. Default implementations provided.", "var_name": "underestimatedCount"}], "subclass_list": ["Collection", "LazySequenceProtocol"], "class_name": "Sequence"}