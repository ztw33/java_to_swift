{"class_inherit_list": [], "Vars": [{"var_description": "A Boolean value that indicates whether the dictionary is empty.", "var_type": "Bool", "var_name": "isEmpty"}, {"var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool", "var_name": "isEmpty"}, {"var_description": "The number of key-value pairs in the dictionary.", "var_type": "Int", "var_name": "count"}, {"var_description": "The number of elements in the collection.", "var_type": "Int", "var_name": "count"}, {"var_description": "The total number of key-value pairs that the dictionary can contain without allocating new storage.", "var_type": "Int", "var_name": "capacity"}, {"var_description": "A collection containing just the keys of the dictionary.", "var_type": "Dictionary<Key,", "var_name": "keys"}, {"var_description": "A collection containing just the values of the dictionary.", "var_type": "Dictionary<Key,", "var_name": "values"}, {"var_description": "The first element of the collection.", "var_type": "(key", "var_name": "first"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<Dictionary<Key,", "var_name": "lazy"}, {"var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<Dictionary<Key,", "var_name": "lazy"}, {"var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "var_type": "Int", "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "var_name": "underestimatedCount"}, {"var_description": "The position of the first element in a nonempty dictionary.", "var_type": "Dictionary<Key,", "var_name": "startIndex"}, {"var_description": "The dictionary\u2019s \u201cpast the end\u201d position\u2014that is, the position one greater than the last valid subscript argument.", "var_type": "Dictionary<Key,", "var_name": "endIndex"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<Dictionary<Key,", "var_name": "indices"}, {"var_description": "A string that represents the contents of the dictionary.", "var_type": "String", "var_name": "description"}, {"var_description": "A string that represents the contents of the dictionary, suitable for debugging.", "var_type": "String", "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the dictionary.", "var_type": "Mirror", "var_name": "customMirror"}, {"var_description": "", "var_type": "MLDataValue", "var_name": "dataValue"}, {"var_description": "The kind of machine learning data value to which the dictionary may be converted.", "var_type": "MLDataValue.ValueType", "var_name": "dataValueType"}], "class_name": "Dictionary", "interface_list": ["Collection", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "CVarArg", "Decodable", "Encodable", "Equatable", "ExpressibleByDictionaryLiteral", "Hashable", "MLDataValueConvertible", "Sequence"], "subclass_list": [], "class_description": "A dictionary is a type of hash table, providing fast access to the entries it contains. Each entry in the table is identified using its key, which is a hashable type such as a string or number. You use that key to retrieve the corresponding value, which can be any object. In other languages, similar data types are known as hashes or associated arrays.\nCreate a new dictionary by using a dictionary literal. A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets. You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.\nHere\u2019s how you would create a dictionary of HTTP response codes and their related messages:\nThe responseMessages variable is inferred to have type [Int: String]. The Key type of the dictionary is Int, and the Value type of the dictionary is String.\nTo create a dictionary with no key-value pairs, use an empty dictionary literal ([:]).\nAny type that conforms to the Hashable protocol can be used as a dictionary\u2019s Key type, including all of Swift\u2019s basic types. You can use your own custom types as dictionary keys by making them conform to the Hashable protocol.\nThe most common way to access values in a dictionary is to use a key as a subscript. Subscripting with a key takes the following form:\nSubscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.\nThe next example uses key-based subscripting of the responseMessages dictionary with two keys that exist in the dictionary and one that does not.\nYou can also update, modify, or remove keys and values from a dictionary using the key-based subscript. To add a new key-value pair, assign a value to a key that isn\u2019t yet a part of the dictionary.\nUpdate an existing value by assigning a new value to a key that already exists in the dictionary. If you assign nil to an existing key, the key and its associated value are removed. The following example updates the value for the 404 code to be simply \u201cNot found\u201d and removes the key-value pair for the 500 code entirely.\nIn a mutable Dictionary instance, you can modify in place a value that you\u2019ve accessed through a keyed subscript. The code sample below declares a dictionary called interestingNumbers with string keys and values that are integer arrays, then sorts each array in-place in descending order.\nEvery dictionary is an unordered collection of key-value pairs. You can iterate over a dictionary using a for-in loop, decomposing each key-value pair into the elements of a tuple.\nThe order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable. If you need an ordered collection of key-value pairs and don\u2019t need the fast key lookup that Dictionary provides, see the DictionaryLiteral type for an alternative.\nYou can search a dictionary\u2019s contents for a particular value using the contains(where:) or firstIndex(where:) methods supplied by default implementation. The following example checks to see if imagePaths contains any paths in the \"/glyphs\" directory:\nNote that in this example, imagePaths is subscripted using a dictionary index. Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a nonoptional tuple.\nA dictionary\u2019s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer. When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.\nWhen you know how many new values you\u2019re adding to a dictionary, use the init(minimumCapacity:) initializer to allocate the correct amount of buffer.\nYou can bridge between Dictionary and NSDictionary using the as operator. For bridging to be possible, the Key and Value types of a dictionary must be classes, @objc protocols, or types that bridge to Foundation types.\nBridging from Dictionary to NSDictionary always takes O(1) time and space. When the dictionary\u2019s Key and Value types are neither classes nor @objc protocols, any required bridging of elements occurs at the first access of each element. For this reason, the first operation that uses the contents of the dictionary may take O(n).\nBridging from NSDictionary to Dictionary first calls the copy(with:) method (- copyWithZone: in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of NSDictionary that are already immutable, copy(with:) usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified. The instances of NSDictionary and Dictionary share buffer using the same copy-on-write optimization that is used when two instances of Dictionary share buffer.\n", "Methods": [{"return_value": {"return_description": ["The index for key and its associated value if key is in the dictionary; otherwise, nil."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "method_description": "Returns the index for the given key.", "method_name": "index", "class_name": "Dictionary", "params": [{"param_description": "The key to find in the dictionary.", "param_type": "Dictionary<Key", "param_name": ["forKey", "key"]}, {"param_description": "", "param_type": "Value>.Key", "param_name": ["Value>.Key"]}]}, {"return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [["key"], ["value"]], "return_type": ["Key", "Value"]}, "method_description": "Returns a random element of the collection.", "method_name": "randomElement", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [["key"], ["value"]], "return_type": ["Key", "Value"]}, "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "class_name": "Dictionary", "params": [{"param_description": "The random number generator to use when choosing a random element.", "param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"]}]}, {"return_value": {"return_description": ["The value that was replaced, or nil if a new key-value pair was added."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Value"]}, "method_description": "Updates the value stored in the dictionary for the given key, or adds a new key-value pair if the key does not exist.", "method_name": "updateValue", "class_name": "Dictionary", "params": [{"param_description": "The new value to add to the dictionary.", "param_type": "Dictionary<Key", "param_name": ["value"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}, {"param_description": "The key to associate with value. If key already exists in the dictionary, value replaces the existing associated value. If key isn\u2019t already a key of the dictionary, the (key, value) pair is added.", "param_type": "Dictionary<Key", "param_name": ["forKey", "key"]}, {"param_description": "", "param_type": "Value>.Key", "param_name": ["Value>.Key"]}]}, {"return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Value rethrows"]}, "method_description": "Merges the given dictionary into this dictionary, using a combining closure to determine the value for any duplicate keys.", "method_name": "merge", "class_name": "Dictionary", "params": [{"param_description": "A dictionary to merge.", "param_type": "[Dictionary<Key", "param_name": ["other"]}, {"param_description": "", "param_type": "Dictionary<Key", "param_name": ["Value>.Key"]}, {"param_description": "", "param_type": "Value>.Value]", "param_name": ["Value>.Value]"]}, {"param_description": "A closure that takes the current and new values for any duplicate keys. The closure returns the desired value for the final dictionary.", "param_type": "(Dictionary<Key", "param_name": ["uniquingKeysWith", "combine"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}, {"param_description": "", "param_type": "Dictionary<Key", "param_name": ["Dictionary<Key"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}]}, {"return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Value rethrows"]}, "method_description": "Merges the key-value pairs in the given sequence into the dictionary, using a combining closure to determine the value for any duplicate keys.", "method_name": "merge", "class_name": "Dictionary", "params": [{"param_description": "A sequence of key-value pairs.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A closure that takes the current and new values for any duplicate keys. The closure returns the desired value for the final dictionary.", "param_type": "(Dictionary<Key", "param_name": ["uniquingKeysWith", "combine"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}, {"param_description": "", "param_type": "Dictionary<Key", "param_name": ["Dictionary<Key"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}]}, {"return_value": {"return_description": ["A new dictionary with the combined keys and values of this dictionary and other."], "return_name": ["", "", ["Value>.Key"], ""], "return_type": ["Dictionary<Key", "Value>.Value rethrows -> [Dictionary<Key", "Dictionary<Key", "Value>.Value]"]}, "method_description": "Creates a dictionary by merging the given dictionary into this dictionary, using a combining closure to determine the value for duplicate keys.", "method_name": "merging", "class_name": "Dictionary", "params": [{"param_description": "A dictionary to merge.", "param_type": "[Dictionary<Key", "param_name": ["other"]}, {"param_description": "", "param_type": "Dictionary<Key", "param_name": ["Value>.Key"]}, {"param_description": "", "param_type": "Value>.Value]", "param_name": ["Value>.Value]"]}, {"param_description": "A closure that takes the current and new values for any duplicate keys. The closure returns the desired value for the final dictionary.", "param_type": "(Dictionary<Key", "param_name": ["uniquingKeysWith", "combine"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}, {"param_description": "", "param_type": "Dictionary<Key", "param_name": ["Dictionary<Key"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}]}, {"return_value": {"return_description": ["A new dictionary with the combined keys and values of this dictionary and other."], "return_name": ["", "", ["Value>.Key"], ""], "return_type": ["Dictionary<Key", "Value>.Value rethrows -> [Dictionary<Key", "Dictionary<Key", "Value>.Value]"]}, "method_description": "Creates a dictionary by merging key-value pairs in a sequence into the dictionary, using a combining closure to determine the value for duplicate keys.", "method_name": "merging", "class_name": "Dictionary", "params": [{"param_description": "A sequence of key-value pairs.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A closure that takes the current and new values for any duplicate keys. The closure returns the desired value for the final dictionary.", "param_type": "(Dictionary<Key", "param_name": ["uniquingKeysWith", "combine"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}, {"param_description": "", "param_type": "Dictionary<Key", "param_name": ["Dictionary<Key"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Reserves enough space to store the specified number of key-value pairs.", "method_name": "reserveCapacity", "class_name": "Dictionary", "params": [{"param_description": "The requested number of key-value pairs to store.", "param_type": "Int", "param_name": ["minimumCapacity"]}]}, {"return_value": {"return_description": ["A dictionary of the key-value pairs that isIncluded allows."], "return_name": ["", ["Value>.Key"], ""], "return_type": ["Bool rethrows -> [Dictionary<Key", "Dictionary<Key", "Value>.Value]"]}, "method_description": "Returns a new dictionary containing the key-value pairs of the dictionary that satisfy the given predicate.", "method_name": "filter", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes a key-value pair as its argument and returns a Boolean value indicating whether the pair should be included in the returned dictionary.", "param_type": "(Dictionary<Key", "param_name": ["isIncluded"]}, {"param_description": "", "param_type": "Value>.Element", "param_name": ["Value>.Element"]}]}, {"return_value": {"return_description": ["The value that was removed, or nil if the key was not present in the dictionary."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Value"]}, "method_description": "Removes the given key and its associated value from the dictionary.", "method_name": "removeValue", "class_name": "Dictionary", "params": [{"param_description": "The key to remove along with its associated value.", "param_type": "Dictionary<Key", "param_name": ["forKey", "key"]}, {"param_description": "", "param_type": "Value>.Key", "param_name": ["Value>.Key"]}]}, {"return_value": {"return_description": ["The key-value pair that correspond to index."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Element"]}, "method_description": "Removes and returns the key-value pair at the specified index.", "method_name": "remove", "class_name": "Dictionary", "params": [{"param_description": "The position of the key-value pair to remove. index must be a valid index of the dictionary, and must not equal the dictionary\u2019s end index.", "param_type": "Dictionary<Key", "param_name": ["at", "index"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Removes all key-value pairs from the dictionary.", "method_name": "removeAll", "class_name": "Dictionary", "params": [{"param_description": "Whether the dictionary should keep its underlying buffer. If you pass true, the operation preserves the buffer capacity that the collection has, otherwise the underlying buffer is released.  The default is false.", "param_type": "Bool", "param_name": ["keepingCapacity", "keepCapacity"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "", "method_name": "==", "class_name": "Dictionary", "params": [{"param_description": "", "param_type": "Value]", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Value]", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "class_name": "Dictionary", "params": [{"param_description": "A value to compare.", "param_type": "Dictionary<Key", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Value>", "param_name": ["Value>"]}, {"param_description": "Another value to compare.", "param_type": "Dictionary<Key", "param_name": ["rhs"]}, {"param_description": "", "param_type": "Value>", "param_name": ["Value>"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "", "method_name": "!=", "class_name": "Dictionary", "params": [{"param_description": "", "param_type": "Value]", "param_name": ["lhs"]}, {"param_description": "", "param_type": "Value]", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "Key", "param_name": ["body"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": ["", ""], "return_type": ["EnumeratedSequence<Dictionary<Key", "Value>>"]}, "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["An iterator over the dictionary with elements of type (key: Key, value: Value)."], "return_name": ["", "", "", ""], "return_type": ["DictionaryIterator<Dictionary<Key", "Value>.Key", "Dictionary<Key", "Value>.Value>"]}, "method_description": "Returns an iterator over the dictionary\u2019s key-value pairs.", "method_name": "makeIterator", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "Key", "param_name": ["where", "predicate"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "Key", "param_name": ["predicate"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "Key", "param_name": ["where", "predicate"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "Key", "param_name": ["where", "predicate"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [["Bool", "rethrows", "->", "key"], ["value"]], "return_type": ["Key", "Value"]}, "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "class_name": "Dictionary", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "Key", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [["Bool", "rethrows", "->", "key"], ["value"]], "return_type": ["Key", "Value"]}, "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "class_name": "Dictionary", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "Key", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["A dictionary containing the keys and transformed values of this dictionary."], "return_name": ["", "", ""], "return_type": ["T rethrows -> Dictionary<Dictionary<Key", "Value>.Key", "T>"]}, "method_description": "Returns a new dictionary containing the keys of this dictionary with the values transformed by the given closure.", "method_name": "mapValues", "class_name": "Dictionary", "params": [{"param_description": "A closure that transforms a value. transform accepts each value of the dictionary as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(Dictionary<Key", "param_name": ["transform"]}, {"param_description": "", "param_type": "Value>.Value", "param_name": ["Value>.Value"]}]}, {"return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result rethrows -> Result"]}, "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "class_name": "Dictionary", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result", "param_name": ["nextPartialResult"]}, {"param_description": "", "param_type": "Key", "param_name": ["(key"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["rethrows -> Result"]}, "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "class_name": "Dictionary", "params": [{"param_description": "The value to use as the initial accumulating value.", "param_type": "Result", "param_name": ["into", "initialResult"]}, {"param_description": "A closure that updates the accumulating value with an element of the sequence.", "param_type": "(inout Result", "param_name": ["updateAccumulatingResult"]}, {"param_description": "", "param_type": "Key", "param_name": ["(key"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "class_name": "Dictionary", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "Key", "param_name": ["transform"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "class_name": "Dictionary", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "Key", "param_name": ["transform"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "class_name": "Dictionary", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "Key", "param_name": ["transform"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["String rethrows -> [String]"]}, "method_description": "", "method_name": "flatMap", "class_name": "Dictionary", "params": [{"param_description": "", "param_type": "Key", "param_name": ["transform"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [["Bool", "rethrows", "->", "[key"], ["value"]], "return_type": ["Key", "Value]"]}, "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "class_name": "Dictionary", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "Key", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "class_name": "Dictionary", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout RandomNumberGenerator", "param_name": ["using", "generator"]}]}, {"return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "class_name": "Dictionary", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "Key", "param_name": ["by", "areEquivalent"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "class_name": "Dictionary", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "Key", "param_name": ["by", "areEquivalent"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "class_name": "Dictionary", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "Key", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "method_description": "", "method_name": "index", "class_name": "Dictionary", "params": [{"param_description": "", "param_type": "Dictionary<Key", "param_name": ["after", "i"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Replaces the given index with its successor.", "method_name": "formIndex", "class_name": "Dictionary", "params": [{"param_description": "A valid index of the collection. i must be less than endIndex.", "param_type": "inout Dictionary<Key", "param_name": ["after", "i"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "class_name": "Dictionary", "params": [{"param_description": "A valid index of the collection.", "param_type": "Dictionary<Key", "param_name": ["i"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "class_name": "Dictionary", "params": [{"param_description": "A valid index of the collection.", "param_type": "inout Dictionary<Key", "param_name": ["i"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}]}, {"return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "class_name": "Dictionary", "params": [{"param_description": "A valid index of the collection.", "param_type": "Dictionary<Key", "param_name": ["i"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}, {"param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_type": "Dictionary<Key", "param_name": ["limitedBy", "limit"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "class_name": "Dictionary", "params": [{"param_description": "A valid index of the collection.", "param_type": "inout Dictionary<Key", "param_name": ["i"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}, {"param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_type": "Dictionary<Key", "param_name": ["limitedBy", "limit"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["Int"]}, "method_description": "Returns the distance between two indices.", "method_name": "distance", "class_name": "Dictionary", "params": [{"param_description": "A valid index of the collection.", "param_type": "Dictionary<Key", "param_name": ["from", "start"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}, {"param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_type": "Dictionary<Key", "param_name": ["to", "end"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "class_name": "Dictionary", "params": [{"param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_type": "Int", "param_name": ["maxLength"]}]}, {"return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "class_name": "Dictionary", "params": [{"param_description": "", "param_type": "Dictionary<Key", "param_name": ["through", "position"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "class_name": "Dictionary", "params": [{"param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_type": "Dictionary<Key", "param_name": ["upTo", "end"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Bool rethrows -> Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_type": "Key", "param_name": ["while", "predicate"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "class_name": "Dictionary", "params": [{"param_description": "The maximum number of elements to return. The value of maxLength must be greater than or equal to zero.", "param_type": "Int", "param_name": ["maxLength"]}]}, {"return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "class_name": "Dictionary", "params": [{"param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_type": "Dictionary<Key", "param_name": ["from", "start"]}, {"param_description": "", "param_type": "Value>.Index", "param_name": ["Value>.Index"]}]}, {"return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence containing all but the first element of the sequence.", "method_name": "dropFirst", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "class_name": "Dictionary", "params": [{"param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Bool rethrows -> Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "class_name": "Dictionary", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_type": "Key", "param_name": ["while", "predicate"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["A subsequence leaving off the last element of the sequence."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence containing all but the last element of the sequence.", "method_name": "dropLast", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["A subsequence that leaves off the specified number of elements at the end."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "class_name": "Dictionary", "params": [{"param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_type": "Int", "param_name": ["k"]}]}, {"return_value": {"return_description": ["The first key-value pair of the dictionary if the dictionary is not empty; otherwise, nil."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Element"]}, "method_description": "Removes and returns the first key-value pair of the dictionary if the dictionary isn\u2019t empty.", "method_name": "popFirst", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "class_name": "Dictionary", "params": [{"param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_type": "Int", "param_name": ["maxSplits"]}, {"param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_type": "Bool", "param_name": ["omittingEmptySubsequences"]}, {"param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_type": "Key", "param_name": ["whereSeparator", "isSeparator"]}, {"param_description": "", "param_type": "Value", "param_name": ["value"]}]}, {"return_value": {"return_description": ["An array containing the elements of this sequence in reverse order."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "method_description": "Returns an array containing the elements of this sequence in reverse order.", "method_name": "reversed", "class_name": "Dictionary", "params": []}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Encodes the contents of this dictionary into the given encoder.", "method_name": "encode", "class_name": "Dictionary", "params": [{"param_description": "The encoder to write data to.", "param_type": "Encoder", "param_name": ["to", "encoder"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "class_name": "Dictionary", "params": [{"param_description": "The hasher to use when combining the components of this instance.", "param_type": "inout Hasher", "param_name": ["into", "hasher"]}]}], "package_name": "swift"}