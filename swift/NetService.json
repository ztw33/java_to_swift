{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": ["Data"], "return_name": [""], "return_description": ["An NSData object representing TXT data formed from txtDictionary. Fails an assertion if txtDictionary cannot be represented as an NSData object."]}, "method_name": "data", "class_name": "NetService", "method_description": "Returns an NSData object representing a TXT record formed from a given dictionary.", "params": [{"param_type": "Data]", "param_name": ["fromTXTRecord", "txtDictionary"], "param_description": ""}]}, {"return_value": {"return_type": ["Data]"], "return_name": [["[String"]], "return_description": ["A dictionary representing txtData. The dictionary\u2019s keys are NSString objects using UTF8 encoding. The values associated with all the dictionary\u2019s keys are NSData objects that encapsulate strings or data."]}, "method_name": "dictionary", "class_name": "NetService", "method_description": "Returns a dictionary representing a TXT record given as an NSData object.", "params": [{"param_type": "Data", "param_name": ["fromTXTRecord", "txtData"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the streams are created successfully, otherwise false."]}, "method_name": "getInputStream", "class_name": "NetService", "method_description": "Creates a pair of input and output streams for the receiver and returns a Boolean value that indicates whether they were retrieved successfully.", "params": [{"param_type": "UnsafeMutablePointer<InputStream>", "param_name": ["inputStream"], "param_description": ""}, {"param_type": "UnsafeMutablePointer<OutputStream>", "param_name": ["outputStream"], "param_description": ""}]}, {"return_value": {"return_type": ["Data"], "return_name": [""], "return_description": []}, "method_name": "txtRecordData", "class_name": "NetService", "method_description": "Returns the TXT record for the receiver.", "params": []}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if recordData is successfully set as the TXT record, otherwise false."]}, "method_name": "setTXTRecord", "class_name": "NetService", "method_description": "Sets the TXT record for the receiver, and returns a Boolean value that indicates whether the operation was successful.", "params": [{"param_type": "Data", "param_name": ["recordData"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "schedule", "class_name": "NetService", "method_description": "Adds the service to the specified run loop.", "params": [{"param_type": "RunLoop", "param_name": ["in", "aRunLoop"], "param_description": ""}, {"param_type": "RunLoop.Mode", "param_name": ["forMode", "mode"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "remove", "class_name": "NetService", "method_description": "Removes the service from the given run loop for a given mode.", "params": [{"param_type": "RunLoop", "param_name": ["from", "aRunLoop"], "param_description": ""}, {"param_type": "RunLoop.Mode", "param_name": ["forMode", "mode"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "publish", "class_name": "NetService", "method_description": "Attempts to advertise the receiver\u2019s on the network.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "publish", "class_name": "NetService", "method_description": "Attempts to advertise the receiver on the network, with the given options.", "params": [{"param_type": "NetService.Options", "param_name": ["options"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "resolve", "class_name": "NetService", "method_description": "Starts a resolve process for the service.DeprecatedUse resolve(withTimeout:) instead.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "resolve", "class_name": "NetService", "method_description": "Starts a resolve process of a finite duration for the service.", "params": [{"param_type": "TimeInterval", "param_name": ["withTimeout", "timeout"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "startMonitoring", "class_name": "NetService", "method_description": "Starts the monitoring of TXT-record updates for the receiver.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "stop", "class_name": "NetService", "method_description": "Halts a currently running attempt to publish or resolve a service.", "params": []}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "stopMonitoring", "class_name": "NetService", "method_description": "Stops the monitoring of TXT-record updates for the receiver.", "params": []}], "Vars": [{"var_type": "[Data]", "var_description": "A read-only array containing NSData objects, each of which contains a socket address for the service.", "var_name": "addresses"}, {"var_type": "String", "var_description": "A string containing the domain for this service.", "var_name": "domain"}, {"var_type": "Bool", "var_description": "Specifies whether to also publish, resolve, or monitor this service over peer-to-peer Bluetooth and Wi-Fi, if available. false by default.", "var_name": "includesPeerToPeer"}, {"var_type": "String", "var_description": "A string containing the name of this service.", "var_name": "name"}, {"var_type": "String", "var_description": "The type of the published service.", "var_name": "type"}, {"var_type": "NetServiceDelegate", "var_description": "The delegate for the receiver.", "var_name": "delegate"}, {"var_type": "Int", "var_description": "The port on which the service is listening for connections.", "var_name": "port"}, {"var_type": "String", "var_description": "A string containing the DNS hostname for this service.", "var_name": "hostName"}, {"var_type": "String", "var_description": "This key identifies the error that occurred during the most recent operation. ", "var_name": "errorCode"}, {"var_type": "String", "var_description": "This key identifies the originator of the error, which is either the NSNetService object or the mach network layer. For most errors, you should not need the value provided by this key.", "var_name": "errorDomain"}], "subclass_list": [], "class_description": "The NetService class represents a network service, either one your application publishes or is a client of. This class and the NetServiceBrowser class use multicast DNS to convey information about network services to and from your application. The API of NetService provides a convenient way to publish the services offered by your application and to resolve the socket address for a service.\nThe types of services you access using NetService are the same types that you access directly using BSD sockets. HTTP and FTP are two services commonly provided by systems. (For a list of common services and the ports used by those services, see the file /etc/services.) Applications can also define their own custom services to provide specific data to clients.\nYou can use the NetService class as either a publisher of a service or a client of a service. If your application publishes a service, your code must acquire a port and prepare a socket to communicate with clients. Once your socket is ready, you use the NetService class to notify clients that your service is ready. If your application is the client of a network service, you can either create an NetService object directly (if you know the exact host and port information) or use an NetServiceBrowser object to browse for services.\nTo publish a service, initialize your NetService object with the service name, domain, type, and port information. All of this information must be valid for the socket created by your application. Once initialized, call the publish() method to broadcast your service information to the network.\nWhen connecting to a service, use the NetServiceBrowser class to locate the service on the network and obtain the corresponding NetService object. Once you have the object, call the resolve(withTimeout:) method to verify that the service is available and ready for your application. If it is, the addresses property provides the socket information you can use to connect to the service.\nThe methods of NetService operate asynchronously so your application is not impacted by the speed of the network. All information about a service is returned to your application through the NetService object\u2019s delegate. You must provide a delegate object to respond to messages and to handle errors appropriately.\n", "class_name": "NetService"}