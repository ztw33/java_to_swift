{"subclass_list": [], "Methods": [{"params": [{"param_name": ["in", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "count", "method_description": "Returns the count of integers in self that intersect range.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "formIntersection", "method_description": "Intersects the IndexSet with other.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "formSymmetricDifference", "method_description": "Exclusive or the IndexSet with other.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "formUnion", "method_description": "Union the IndexSet with other.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "intersection", "method_description": "Intersects the IndexSet with other.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "symmetricDifference", "method_description": "Exclusive or the IndexSet with other.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "union", "method_description": "Union the IndexSet with other.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "insert", "method_description": "Insert an integer into the IndexSet.", "return_value": {"return_description": [], "return_name": [["inserted"], ["memberAfterInsert"]], "return_type": ["Bool", "IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "insert", "method_description": "Insert a range of integers into the IndexSet.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["with", "integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "update", "method_description": "Insert an integer into the IndexSet.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "remove", "method_description": "Remove an integer from the IndexSet.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "remove", "method_description": "Remove a range of integers from the IndexSet.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "ClosedRange<IndexSet.Element>"}], "method_name": "remove", "method_description": "Remove a range of integers from the IndexSet.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [], "method_name": "removeAll", "method_description": "Remove all values from the IndexSet.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "subtract", "method_description": "Removes the elements of the given set from this set.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "subtracting", "method_description": "Returns a new set containing the elements of this set that do not occur in the given set.", "return_value": {"return_description": ["A new set."], "return_name": [""], "return_type": ["IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "contains", "method_description": "Returns true if self contains integer.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "indexSet"], "param_description": "", "param_type": "IndexSet"}], "method_name": "contains", "method_description": "Returns true if self contains all of the integers in indexSet.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "contains", "method_description": "Returns true if self contains all of the integers in range.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "contains", "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "intersects", "method_description": "Returns true if self intersects any of the integers in range.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["with", "other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "isDisjoint", "method_description": "Returns a Boolean value that indicates whether the set has no members in common with the given set.", "return_value": {"return_description": ["true if the set has no elements in common with other; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "isStrictSubset", "method_description": "Returns a Boolean value that indicates whether this set is a strict subset of the given set.", "return_value": {"return_description": ["true if the set is a strict subset of other; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "isStrictSuperset", "method_description": "Returns a Boolean value that indicates whether this set is a strict superset of the given set.", "return_value": {"return_description": ["true if the set is a strict superset of other; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "isSubset", "method_description": "Returns a Boolean value that indicates whether the set is a subset of another set.", "return_value": {"return_description": ["true if the set is a subset of other; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "other"], "param_description": "", "param_type": "IndexSet"}], "method_name": "isSuperset", "method_description": "Returns a Boolean value that indicates whether the set is a superset of the given set.", "return_value": {"return_description": ["true if the set is a superset of other; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "index", "method_description": "Returns the index that follows the given index in the set.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Index"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "index", "method_description": "Returns the index that precedes the given index in the set.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Index"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["after", "i"], "param_description": "", "param_type": "inout IndexSet.Index"}], "method_name": "formIndex", "method_description": "Modifies the given index to refer to the item after the one it currently refers to.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["before", "i"], "param_description": "", "param_type": "inout IndexSet.Index"}], "method_name": "formIndex", "method_description": "Modifies the given index to refer to the item before the one it currently refers to.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["in", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "indexRange", "method_description": "Return a Range<IndexSet.Index> which can be used to subscript the index set.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<IndexSet.Index>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "first", "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet"}, {"params": [], "method_name": "max", "method_description": "Returns the maximum element in the sequence.", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "max", "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Bool rethrows -> Int"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "min", "method_description": "Returns the minimum element in the sequence.", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "min", "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Bool rethrows -> Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "integerLessThanOrEqualTo", "method_description": "Returns an integer contained in self which is less than or equal to integer, or nil if a result could not be found.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "integerGreaterThan", "method_description": "Returns an integer contained in self which is greater than integer, or nil if a result could not be found.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "integerGreaterThanOrEqualTo", "method_description": "Returns an integer contained in self which is greater than or equal to integer, or nil if a result could not be found.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integer"], "param_description": "", "param_type": "IndexSet.Element"}], "method_name": "integerLessThan", "method_description": "Returns an integer contained in self which is less than integer, or nil if a result could not be found.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Element"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["isIncluded"], "param_description": "", "param_type": "(Int"}], "method_name": "filter", "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "return_value": {"return_description": ["An array of the elements that isIncluded allowed."], "return_name": [""], "return_type": ["Bool rethrows -> [Int]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["in", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}, {"param_name": ["includeInteger"], "param_description": "", "param_type": "(IndexSet.Element"}], "method_name": "filteredIndexSet", "method_description": "Returns an IndexSet filtered according to the result of includeInteger.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["in", "range"], "param_description": "", "param_type": "ClosedRange<IndexSet.Element>"}, {"param_name": ["includeInteger"], "param_description": "", "param_type": "(IndexSet.Element"}], "method_name": "filteredIndexSet", "method_description": "Returns an IndexSet filtered according to the result of includeInteger.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["includeInteger"], "param_description": "", "param_type": "(IndexSet.Element"}], "method_name": "filteredIndexSet", "method_description": "Returns an IndexSet filtered according to the result of includeInteger.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> IndexSet"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "prefix", "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["through", "position"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection through the specified position.", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["upTo", "end"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "prefix", "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["while", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "prefix", "method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["maxLength"], "param_description": "", "param_type": "Int"}], "method_name": "suffix", "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "suffix", "method_description": "Returns a subsequence from the specified position to the end of the collection.", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the last element of the sequence.", "return_value": {"return_description": ["A subsequence leaving off the last element of the sequence."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropLast", "method_description": "Returns a subsequence containing all but the specified number of final elements.", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the first element of the sequence.", "return_value": {"return_description": ["A subsequence starting after the first element of the sequence."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["k"], "param_description": "", "param_type": "Int"}], "method_name": "dropFirst", "method_description": "Returns a subsequence containing all but the given number of initial elements.", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["while", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "drop", "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows -> Slice<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["initialResult"], "param_description": "", "param_type": "Result"}, {"param_name": ["nextPartialResult"], "param_description": "", "param_type": "(Result"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "reduce", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result rethrows -> Result"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["body"], "param_description": "", "param_type": "(Int"}], "method_name": "forEach", "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "enumerated", "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "makeIterator", "method_description": "Returns an iterator over the elements of this sequence.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "sorted", "method_description": "Returns the elements of the sequence, sorted.", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "sorted", "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["Bool rethrows -> [Int]"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "reversed", "method_description": "Returns a view presenting the elements of the collection in reverse order.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<IndexSet>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["startingAt", "integer"], "param_description": "", "param_type": "IndexSet.Element"}, {"param_name": ["by", "delta"], "param_description": "", "param_type": "Int"}], "method_name": "shift", "method_description": "For a positive delta, shifts the indexes in [index, INT_MAX] to the right, thereby inserting an \u201cempty space\u201d [index, delta], for a negative delta, shifts the indexes in [index, INT_MAX] to the left, thereby deleting the indexes in the range [index - delta, delta].", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}, {"param_name": ["whereSeparator", "isSeparator"], "param_description": "", "param_type": "(Int"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["separator"], "param_description": "", "param_type": "Int"}, {"param_name": ["maxSplits"], "param_description": "", "param_type": "Int"}, {"param_name": ["omittingEmptySubsequences"], "param_description": "", "param_type": "Bool"}], "method_name": "split", "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[Slice<IndexSet>]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexSet"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexSet"}], "method_name": "!=", "method_description": "Returns a Boolean value indicating whether two values are not equal.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["lhs"], "param_description": "", "param_type": "IndexSet"}, {"param_name": ["rhs"], "param_description": "", "param_type": "IndexSet"}], "method_name": "==", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "range"], "param_description": "", "param_type": "Range<IndexSet.Element>"}], "method_name": "rangeView", "method_description": "Returns a Range-based view of self.", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "allSatisfy", "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "compactMap", "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["ElementOfResult rethrows -> [ElementOfResult]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "RangeExpression"}], "method_name": "contains", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["in", "range"], "param_description": "", "param_type": "RangeExpression"}], "method_name": "count", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["from", "start"], "param_description": "", "param_type": "IndexSet.Index"}, {"param_name": ["to", "end"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "distance", "method_description": "Returns the distance between two indices.", "return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areEquivalent"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Sequence.Element"], "param_description": "", "param_type": "Sequence.Element"}], "method_name": "elementsEqual", "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["to", "encoder"], "param_description": "", "param_type": "Encoder"}], "method_name": "encode", "method_description": "", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "element"], "param_description": "", "param_type": "Int"}], "method_name": "firstIndex", "method_description": "Returns the first index where the specified value appears in the collection.", "return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["IndexSet.Index"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "firstIndex", "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "flatMap", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["String rethrows -> [String]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "inout IndexSet.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}], "method_name": "formIndex", "method_description": "Offsets the given index by the specified distance.", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "inout IndexSet.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}, {"param_name": ["limitedBy", "limit"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "formIndex", "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "IndexSet.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}], "method_name": "index", "method_description": "Returns an index that is the specified distance from the given index.", "return_value": {"return_description": ["An index offset by n from the index i. If n is positive, this is the same value as the result of n calls to index(after:). If n is negative, this is the same value as the result of -n calls to index(before:)."], "return_name": [""], "return_type": ["IndexSet.Index"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["i"], "param_description": "", "param_type": "IndexSet.Index"}, {"param_name": ["offsetBy", "distance"], "param_description": "", "param_type": "Int"}, {"param_name": ["limitedBy", "limit"], "param_description": "", "param_type": "IndexSet.Index"}], "method_name": "index", "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "return_value": {"return_description": ["An index offset by n from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["IndexSet.Index"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["in", "range"], "param_description": "", "param_type": "RangeExpression"}], "method_name": "indexRange", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<IndexSet.Index>"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "RangeExpression"}], "method_name": "insert", "method_description": "", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "class_name": "IndexSet"}, {"params": [{"param_name": ["integersIn", "range"], "param_description": "", "param_type": "RangeExpression"}], "method_name": "intersects", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "last", "method_description": "Returns the last element of the sequence that satisfies the given predicate.", "return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "element"], "param_description": "", "param_type": "Int"}], "method_name": "lastIndex", "method_description": "Returns the last index where the specified value appears in the collection.", "return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["IndexSet.Index"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["where", "predicate"], "param_description": "", "param_type": "(Int"}], "method_name": "lastIndex", "method_description": "Returns the index of the last element in the collection that matches the given predicate.", "return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}], "method_name": "lexicographicallyPrecedes", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["other"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areInIncreasingOrder"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "lexicographicallyPrecedes", "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "map", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["transform"], "param_description": "", "param_type": "(Int"}], "method_name": "map", "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["T rethrows -> [T]"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "randomElement", "method_description": "Returns a random element of the collection.", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "randomElement", "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["of", "range"], "param_description": "", "param_type": "RangeExpression"}], "method_name": "rangeView", "method_description": "", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["into", "initialResult"], "param_description": "", "param_type": "Result"}, {"param_name": ["updateAccumulatingResult"], "param_description": "", "param_type": "(inout Result"}, {"param_name": ["Int"], "param_description": "", "param_type": "Int"}], "method_name": "reduce", "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["rethrows -> Result"]}, "class_name": "IndexSet"}, {"params": [], "method_name": "shuffled", "method_description": "Returns the elements of the sequence, shuffled.", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["using", "generator"], "param_description": "", "param_type": "inout RandomNumberGenerator"}], "method_name": "shuffled", "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Int]"]}, "class_name": "IndexSet"}, {"params": [{"param_name": ["with", "possiblePrefix"], "param_description": "", "param_type": "Sequence"}, {"param_name": ["by", "areEquivalent"], "param_description": "", "param_type": "(Int"}, {"param_name": ["Sequence.Element"], "param_description": "", "param_type": "Sequence.Element"}], "method_name": "starts", "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool rethrows -> Bool"]}, "class_name": "IndexSet"}], "Vars": [{"var_name": "startIndex", "var_description": "The beginning index in the set.", "var_type": "IndexSet.Index"}, {"var_name": "endIndex", "var_description": "The ending index in the set.", "var_type": "IndexSet.Index"}, {"var_name": "lazy", "var_description": "A view onto this collection that provides lazy implementations of normally eager operations, such as map and filter.", "var_type": "LazyCollection<IndexSet>"}, {"var_name": "lazy", "var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<IndexSet>"}, {"var_name": "rangeView", "var_description": "Returns a Range-based view of the entire contents of self.", "var_type": "IndexSet.RangeView"}, {"var_name": "description", "var_description": "A textual description of the index set.", "var_type": "String"}, {"var_name": "debugDescription", "var_description": "A textual description of the index set suitable for debugging.", "var_type": "String"}, {"var_name": "customMirror", "var_description": "A mirror that reflects the index set.", "var_type": "Mirror"}, {"var_name": "hashValue", "var_description": "The computed hash value for the index set.", "var_type": "Int"}, {"var_name": "count", "var_description": "", "var_type": "Int"}, {"var_name": "count", "var_description": "The number of elements in the collection.", "var_type": "Int"}, {"var_name": "first", "var_description": "The first integer in self, or nil if self is empty.", "var_type": "IndexSet.Element"}, {"var_name": "first", "var_description": "The first element of the collection.", "var_type": "Int"}, {"var_name": "indices", "var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<IndexSet>"}, {"var_name": "isEmpty", "var_description": "A Boolean value that indicates whether the set has no elements.", "var_type": "Bool"}, {"var_name": "isEmpty", "var_description": "", "var_type": "Bool"}, {"var_name": "isEmpty", "var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool"}, {"var_name": "last", "var_description": "The last integer in self, or nil if self is empty.", "var_type": "IndexSet.Element"}, {"var_name": "last", "var_description": "The last element of the collection.", "var_type": "Int"}, {"var_name": "underestimatedCount", "var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "var_type": "Int"}, {"var_name": "underestimatedCount", "var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int"}], "class_name": "IndexSet", "class_inherit_list": [], "interface_list": ["BidirectionalCollection", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "ReferenceConvertible", "SetAlgebra"], "class_description": "The range of valid integer values is 0..<INT_MAX-1. Anything outside this range is an error.\n", "package_name": "foundation"}