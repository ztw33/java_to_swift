{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Hashable", "NSLocking"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the lock is acquired before limit, otherwise false."]}, "method_name": "lock", "class_name": "NSLock", "method_description": "Attempts to acquire a lock before a given time and returns a Boolean value indicating whether the attempt was successful.", "params": [{"param_type": "Date", "param_name": ["before", "limit"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the lock was acquired, otherwise false."]}, "method_name": "`try`", "class_name": "NSLock", "method_description": "Attempts to acquire a lock and immediately returns a Boolean value that indicates whether the attempt was successful.", "params": []}], "Vars": [{"var_type": "String", "var_description": "The name associated with the receiver.", "var_name": "name"}], "subclass_list": [], "class_description": "An NSLock object can be used to mediate access to an application\u2019s global data or to protect a critical section of code, allowing it to run atomically.\nWarning\nThe NSLock class uses POSIX threads to implement its locking behavior. When sending an unlock message to an NSLock object, you must be sure that message is sent from the same thread that sent the initial lock message. Unlocking a lock from a different thread can result in undefined behavior.\nYou should not use this class to implement a recursive lock. Calling the lock method twice on the same thread will lock up your thread permanently. Use the NSRecursiveLock class to implement recursive locks instead.\nUnlocking a lock that is not locked is considered a programmer error and should be fixed in your code. The NSLock class reports such errors by printing an error message to the console when they occur. \n", "class_name": "NSLock"}