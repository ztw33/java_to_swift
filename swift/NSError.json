{"package_name": "foundation", "interface_list": ["CVarArg", "Equatable", "Error", "Hashable", "NSCopying", "NSSecureCoding"], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_type": ["Any = nil"], "return_name": [""], "return_description": []}, "method_name": "setUserInfoValueProvider", "class_name": "NSError", "method_description": "Specifies a block that is called from the implementations of localizedDescription, localizedFailureReason, localizedRecoverySuggestion, localizedRecoveryOptions, recoveryAttempter, and helpAnchor when the underlying value for any of those properties is not present in the userInfo dictionary of NSError instances with the specified domain.", "params": [{"param_type": "String", "param_name": ["forDomain", "errorDomain"], "param_description": ""}, {"param_type": "((Error", "param_name": ["provider"], "param_description": ""}, {"param_type": "String", "param_name": ["String"], "param_description": ""}]}, {"return_value": {"return_type": ["Error", "String -> Any"], "return_name": ["", ""], "return_description": ["The user info provider of the error domain, or nil if none is specified."]}, "method_name": "userInfoValueProvider", "class_name": "NSError", "method_description": "Returns any user info provider specified by the setUserInfoValueProvider(forDomain:provider:) method for a given error domain.", "params": [{"param_type": "String", "param_name": ["forDomain", "errorDomain"], "param_description": ""}]}, {"return_value": {"return_type": [], "return_name": [], "return_description": []}, "method_name": "attemptRecovery", "class_name": "NSError", "method_description": "Implemented to attempt a recovery from an error noted in a document-modal sheet.", "params": [{"param_type": "Error", "param_name": ["fromError", "error"], "param_description": ""}, {"param_type": "Int", "param_name": ["optionIndex", "recoveryOptionIndex"], "param_description": ""}, {"param_type": "Any", "param_name": ["delegate"], "param_description": ""}, {"param_type": "Selector", "param_name": ["didRecoverSelector"], "param_description": ""}, {"param_type": "UnsafeMutableRawPointer", "param_name": ["contextInfo"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the error recovery was completed successfully, false otherwise."]}, "method_name": "attemptRecovery", "class_name": "NSError", "method_description": "Implemented to attempt a recovery from an error noted in an application-modal dialog.", "params": [{"param_type": "Error", "param_name": ["fromError", "error"], "param_description": ""}, {"param_type": "Int", "param_name": ["optionIndex", "recoveryOptionIndex"], "param_description": ""}]}, {"return_value": {"return_type": ["Self"], "return_name": [""], "return_description": []}, "method_name": "fileProviderErrorForCollision", "class_name": "NSError", "method_description": "Returns a properly formatted error object with a NSFileProviderItemCollisionError error code.", "params": [{"param_type": "NSFileProviderItem", "param_name": ["with", "existingItem"], "param_description": ""}]}, {"return_value": {"return_type": ["Self"], "return_name": [""], "return_description": []}, "method_name": "fileProviderErrorForNonExistentItem", "class_name": "NSError", "method_description": "", "params": [{"param_type": "NSFileProviderItemIdentifier", "param_name": ["withIdentifier", "itemIdentifier"], "param_description": ""}]}], "Vars": [{"var_type": "Int", "var_description": "The error code.", "var_name": "code"}, {"var_type": "String", "var_description": "A string containing the error domain.", "var_name": "domain"}, {"var_type": "[String", "var_description": "The user info dictionary. ", "var_name": "userInfo"}, {"var_type": "String", "var_description": "A string containing the localized description of the error.", "var_name": "localizedDescription"}, {"var_type": "[String]", "var_description": "An array containing the localized titles of buttons appropriate for displaying in an alert panel.", "var_name": "localizedRecoveryOptions"}, {"var_type": "String", "var_description": "A string containing the localized recovery suggestion for the error.", "var_name": "localizedRecoverySuggestion"}, {"var_type": "String", "var_description": "A string containing the localized explanation of the reason for the error.", "var_name": "localizedFailureReason"}, {"var_type": "Any", "var_description": "The object in the user info dictionary corresponding to the NSRecoveryAttempterErrorKey key.", "var_name": "recoveryAttempter"}, {"var_type": "String", "var_description": "A string to display in response to an alert panel help anchor button being pressed.", "var_name": "helpAnchor"}, {"var_type": "String", "var_description": "Cocoa errors", "var_name": "NSCocoaErrorDomain"}, {"var_type": "String", "var_description": "POSIX/BSD errors", "var_name": "NSPOSIXErrorDomain"}, {"var_type": "String", "var_description": "Mac OS 9/Carbon errors", "var_name": "NSOSStatusErrorDomain"}, {"var_type": "String", "var_description": "Mach errors", "var_name": "NSMachErrorDomain"}, {"var_type": "String", "var_description": "URL loading system errors", "var_name": "NSURLErrorDomain"}, {"var_type": "String", "var_description": "The error domain used by NSError when reporting SOCKS errors.", "var_name": "NSStreamSOCKSErrorDomain"}, {"var_type": "String", "var_description": "The error domain used by NSError when reporting SSL errors.", "var_name": "NSStreamSocketSSLErrorDomain"}, {"var_type": "Int", "var_description": "", "var_name": "NSBundleErrorMaximum"}, {"var_type": "Int", "var_description": "", "var_name": "NSBundleErrorMinimum"}, {"var_type": "Int", "var_description": "", "var_name": "NSBundleOnDemandResourceExceededMaximumSizeError"}, {"var_type": "Int", "var_description": "", "var_name": "NSBundleOnDemandResourceInvalidTagError"}, {"var_type": "Int", "var_description": "", "var_name": "NSBundleOnDemandResourceOutOfSpaceError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingConflictError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingErrorMaximum"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingErrorMinimum"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingNetworkFailureError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingNoPermissionError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingOtherError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingQuotaExceededError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCloudSharingTooManyParticipantsError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCoderErrorMaximum"}, {"var_type": "Int", "var_description": "", "var_name": "NSCoderErrorMinimum"}, {"var_type": "Int", "var_description": "", "var_name": "NSCoderReadCorruptError"}, {"var_type": "Int", "var_description": "", "var_name": "NSCoderValueNotFoundError"}, {"var_type": "Int", "var_description": "Executable does not provide an architecture compatible with the current process.", "var_name": "NSExecutableArchitectureMismatchError"}, {"var_type": "Int", "var_description": "Marks end of the range of error codes reserved for errors related to executable files.", "var_name": "NSExecutableErrorMaximum"}, {"var_type": "Int", "var_description": "Marks beginning of the range of error codes reserved for errors related to executable files.", "var_name": "NSExecutableErrorMinimum"}, {"var_type": "Int", "var_description": "Executable fails due to linking issues.", "var_name": "NSExecutableLinkError"}, {"var_type": "Int", "var_description": "Executable cannot be loaded for some other reason, such as a problem with a library it depends on.", "var_name": "NSExecutableLoadError"}, {"var_type": "Int", "var_description": "Executable is of a type that is not loadable in the current process.", "var_name": "NSExecutableNotLoadableError"}, {"var_type": "Int", "var_description": "Executable has Objective C runtime information incompatible with the current process.", "var_name": "NSExecutableRuntimeMismatchError"}, {"var_type": "Int", "var_description": "The feature is not supported, either because the file system lacks the feature, or required libraries are missing, or other similar reasons.", "var_name": "NSFeatureUnsupportedError"}, {"var_type": "Int", "var_description": "Marks the start of the range of error codes reserved for formatting errors.", "var_name": "NSFormattingErrorMinimum"}, {"var_type": "Int", "var_description": "Marks end of the range of error codes reserved for formatting errors.", "var_name": "NSFormattingErrorMaximum"}, {"var_type": "Int", "var_description": "Marks the end of the range of error codes reserved for file errors.", "var_name": "NSFileErrorMaximum"}, {"var_type": "Int", "var_description": "Marks the start of the range of error codes reserved for file errors.", "var_name": "NSFileErrorMinimum"}, {"var_type": "Int", "var_description": "Failure to get a lock on file.", "var_name": "NSFileLockingError"}, {"var_type": "Int", "var_description": "The volume could not be unmounted because it is in use.", "var_name": "NSFileManagerUnmountBusyError"}, {"var_type": "Int", "var_description": "The volume could not be unmounted, reason unknown.", "var_name": "NSFileManagerUnmountUnknownError"}, {"var_type": "Int", "var_description": "File-system operation attempted on non-existent file.", "var_name": "NSFileNoSuchFileError"}, {"var_type": "Int", "var_description": "Read error because of a corrupted file, bad format, or similar reason.", "var_name": "NSFileReadCorruptFileError"}, {"var_type": "Int", "var_description": "Read error because the string encoding was not applicable.", "var_name": "NSFileReadInapplicableStringEncodingError"}, {"var_type": "Int", "var_description": "Read error because of an invalid file name.", "var_name": "NSFileReadInvalidFileNameError"}, {"var_type": "Int", "var_description": "Read error because of a permission problem.", "var_name": "NSFileReadNoPermissionError"}, {"var_type": "Int", "var_description": "Read error because no such file was found.", "var_name": "NSFileReadNoSuchFileError"}, {"var_type": "Int", "var_description": "Read error because the specified file was too large.", "var_name": "NSFileReadTooLargeError"}, {"var_type": "Int", "var_description": "Read error, reason unknown.", "var_name": "NSFileReadUnknownError"}, {"var_type": "Int", "var_description": "Read error because the string coding of the file could not be determined.", "var_name": "NSFileReadUnknownStringEncodingError"}, {"var_type": "Int", "var_description": "Read error because the specified URL scheme is unsupported.", "var_name": "NSFileReadUnsupportedSchemeError"}, {"var_type": "Int", "var_description": "Write error returned when NSFileManager class\u2019s copy, move, and link methods report errors when the destination file already exists.", "var_name": "NSFileWriteFileExistsError"}, {"var_type": "Int", "var_description": "Write error because the string encoding was not applicable.", "var_name": "NSFileWriteInapplicableStringEncodingError"}, {"var_type": "Int", "var_description": "Write error because of an invalid file name.", "var_name": "NSFileWriteInvalidFileNameError"}, {"var_type": "Int", "var_description": "Write error because of a permission problem.", "var_name": "NSFileWriteNoPermissionError"}, {"var_type": "Int", "var_description": "Write error because of a lack of disk space.", "var_name": "NSFileWriteOutOfSpaceError"}, {"var_type": "Int", "var_description": "Write error, reason unknown.", "var_name": "NSFileWriteUnknownError"}, {"var_type": "Int", "var_description": "Write error because the specified URL scheme is unsupported.", "var_name": "NSFileWriteUnsupportedSchemeError"}, {"var_type": "Int", "var_description": "Write error because the volume is read-only.", "var_name": "NSFileWriteVolumeReadOnlyError"}, {"var_type": "Int", "var_description": "Formatting error (related to display of data)", "var_name": "NSFormattingError"}, {"var_type": "Int", "var_description": "Key-value coding validation error.", "var_name": "NSKeyValueValidationError"}, {"var_type": "Int", "var_description": "Marks end of the range of error codes reserved for property list errors.", "var_name": "NSPropertyListErrorMaximum"}, {"var_type": "Int", "var_description": "Marks beginning of the range of error codes reserved for property list errors.", "var_name": "NSPropertyListErrorMinimum"}, {"var_type": "Int", "var_description": "An error was encountered while parsing the property list.", "var_name": "NSPropertyListReadCorruptError"}, {"var_type": "Int", "var_description": "A stream error was encountered while reading the property list.", "var_name": "NSPropertyListReadStreamError"}, {"var_type": "Int", "var_description": "The version number of the property list is unable to be determined.", "var_name": "NSPropertyListReadUnknownVersionError"}, {"var_type": "Int", "var_description": "", "var_name": "NSPropertyListWriteInvalidError"}, {"var_type": "Int", "var_description": "A stream error was encountered while writing the property list.", "var_name": "NSPropertyListWriteStreamError"}, {"var_type": "Int", "var_description": "The maximum error code value that represents an iCloud error.", "var_name": "NSUbiquitousFileErrorMaximum"}, {"var_type": "Int", "var_description": "The minimum error code value that represents an iCloud error.", "var_name": "NSUbiquitousFileErrorMinimum"}, {"var_type": "Int", "var_description": "The item could not be uploaded to iCloud because it would make the account go over its quota.", "var_name": "NSUbiquitousFileNotUploadedDueToQuotaError"}, {"var_type": "Int", "var_description": "Connecting to the iCloud servers failed.", "var_name": "NSUbiquitousFileUbiquityServerNotAvailable"}, {"var_type": "Int", "var_description": "The item has not been uploaded to iCloud by another device yet.", "var_name": "NSUbiquitousFileUnavailableError"}, {"var_type": "Int", "var_description": "", "var_name": "NSUserActivityConnectionUnavailableError"}, {"var_type": "Int", "var_description": "", "var_name": "NSUserActivityErrorMaximum"}, {"var_type": "Int", "var_description": "", "var_name": "NSUserActivityErrorMinimum"}, {"var_type": "Int", "var_description": "", "var_name": "NSUserActivityHandoffFailedError"}, {"var_type": "Int", "var_description": "", "var_name": "NSUserActivityHandoffUserInfoTooLargeError"}, {"var_type": "Int", "var_description": "", "var_name": "NSUserActivityRemoteApplicationTimedOutError"}, {"var_type": "Int", "var_description": "The user cancelled the operation (for example, by pressing Command-period).", "var_name": "NSUserCancelledError"}, {"var_type": "Int", "var_description": "Marks the start of the range of error codes reserved for validation errors.", "var_name": "NSValidationErrorMinimum"}, {"var_type": "Int", "var_description": "Marks the start and end of the range of error codes reserved for validation errors.", "var_name": "NSValidationErrorMaximum"}, {"var_type": "Int", "var_description": "The upper bounds of XPC connection error code values. All XPC error codes have values between NSXPCConnectionErrorMinimum and NSXPCConnectionErrorMaximum, exclusive. This constant does not correspond to any particular error.", "var_name": "NSXPCConnectionErrorMaximum"}, {"var_type": "Int", "var_description": "The lower bounds of XPC connection error code values. All XPC error codes have values between NSXPCConnectionErrorMinimum and NSXPCConnectionErrorMaximum, exclusive. This constant does not correspond to any particular error.", "var_name": "NSXPCConnectionErrorMinimum"}, {"var_type": "Int", "var_description": "The XPC connection was interrupted.", "var_name": "NSXPCConnectionInterrupted"}, {"var_type": "Int", "var_description": "The XPC connection was invalid.", "var_name": "NSXPCConnectionInvalid"}, {"var_type": "Int", "var_description": "The XPC connection reply was invalid.", "var_name": "NSXPCConnectionReplyInvalid"}, {"var_type": "Int", "var_description": "App Transport Security disallowed a connection because there is no secure network connection.", "var_name": "NSURLErrorAppTransportSecurityRequiresSecureConnection"}, {"var_type": "Int", "var_description": "An app or app extension attempted to connect to a background session that is already connected to a process.", "var_name": "NSURLErrorBackgroundSessionInUseByAnotherProcess"}, {"var_type": "Int", "var_description": "The shared container identifier of the URL session configuration is needed but has not been set.", "var_name": "NSURLErrorBackgroundSessionRequiresSharedContainer"}, {"var_type": "Int", "var_description": "The app is suspended or exits while a background data task is processing.", "var_name": "NSURLErrorBackgroundSessionWasDisconnected"}, {"var_type": "Int", "var_description": "The URL Loading system received bad data from the server.", "var_name": "NSURLErrorBadServerResponse"}, {"var_type": "Int", "var_description": "A malformed URL prevented a URL request from being initiated.", "var_name": "NSURLErrorBadURL"}, {"var_type": "Int", "var_description": "A connection was attempted while a phone call was active on a network that does not support simultaneous phone and data communication (EDGE or GPRS).", "var_name": "NSURLErrorCallIsActive"}, {"var_type": "Int", "var_description": "An asynchronous load has been canceled.", "var_name": "NSURLErrorCancelled"}, {"var_type": "Int", "var_description": "A download task couldn\u2019t close the downloaded file on disk.", "var_name": "NSURLErrorCannotCloseFile"}, {"var_type": "Int", "var_description": "An attempt to connect to a host failed. ", "var_name": "NSURLErrorCannotConnectToHost"}, {"var_type": "Int", "var_description": "A download task couldn\u2019t create the downloaded file on disk because of an I/O failure.", "var_name": "NSURLErrorCannotCreateFile"}, {"var_type": "Int", "var_description": "Content data received during a connection request had an unknown content encoding.", "var_name": "NSURLErrorCannotDecodeContentData"}, {"var_type": "Int", "var_description": "Content data received during a connection request could not be decoded for a known content encoding.", "var_name": "NSURLErrorCannotDecodeRawData"}, {"var_type": "Int", "var_description": "The host name for a URL could not be resolved.", "var_name": "NSURLErrorCannotFindHost"}, {"var_type": "Int", "var_description": "A specific request to load an item only from the cache could not be satisfied. ", "var_name": "NSURLErrorCannotLoadFromNetwork"}, {"var_type": "Int", "var_description": "A NSURLDownload instance was unable to move a downloaded file on disk.", "var_name": "NSURLErrorCannotMoveFile"}, {"var_type": "Int", "var_description": "A NSURLDownload instance was unable to open the downloaded file on disk.", "var_name": "NSURLErrorCannotOpenFile"}, {"var_type": "Int", "var_description": "A response to a connection request could not be parsed.", "var_name": "NSURLErrorCannotParseResponse"}, {"var_type": "Int", "var_description": "A NSURLDownload instance was unable to remove a downloaded file from disk.", "var_name": "NSURLErrorCannotRemoveFile"}, {"var_type": "Int", "var_description": "A NSURLDownload instance was unable to write to the downloaded file on disk.", "var_name": "NSURLErrorCannotWriteToFile"}, {"var_type": "Int", "var_description": "A server certificate was rejected.", "var_name": "NSURLErrorClientCertificateRejected"}, {"var_type": "Int", "var_description": "A client certificate was required to authenticate an SSL connection during a connection request.", "var_name": "NSURLErrorClientCertificateRequired"}, {"var_type": "Int", "var_description": "The host address could not be found via DNS lookup.", "var_name": "NSURLErrorDNSLookupFailed"}, {"var_type": "Int", "var_description": "The length of the resource data exceeded the maximum allowed.", "var_name": "NSURLErrorDataLengthExceedsMaximum"}, {"var_type": "Int", "var_description": "The cellular network disallowed a connection.", "var_name": "NSURLErrorDataNotAllowed"}, {"var_type": "Int", "var_description": "A NSURLDownload instance failed to decode an encoded file during the download.", "var_name": "NSURLErrorDownloadDecodingFailedMidStream"}, {"var_type": "Int", "var_description": "A NSURLDownload instance failed to decode an encoded file after downloading.", "var_name": "NSURLErrorDownloadDecodingFailedToComplete"}, {"var_type": "Int", "var_description": "A file does not exist.", "var_name": "NSURLErrorFileDoesNotExist"}, {"var_type": "Int", "var_description": "A request for an FTP file resulted in the server responding that the file is not a plain file, but a directory.", "var_name": "NSURLErrorFileIsDirectory"}, {"var_type": "Int", "var_description": "An internal file operation failed.", "var_name": "NSURLErrorFileOutsideSafeArea"}, {"var_type": "Int", "var_description": "A redirect loop was detected or when the threshold for number of allowable redirects was exceeded (currently 16).", "var_name": "NSURLErrorHTTPTooManyRedirects"}, {"var_type": "Int", "var_description": "The attempted connection required activating a data context while roaming, but international roaming is disabled.", "var_name": "NSURLErrorInternationalRoamingOff"}, {"var_type": "Int", "var_description": "A client or server connection was severed in the middle of an in-progress load.", "var_name": "NSURLErrorNetworkConnectionLost"}, {"var_type": "Int", "var_description": "A resource couldn\u2019t be read because of insufficient permissions.", "var_name": "NSURLErrorNoPermissionsToReadFile"}, {"var_type": "Int", "var_description": "A network resource was requested, but an internet connection has not been established and cannot be established automatically.", "var_name": "NSURLErrorNotConnectedToInternet"}, {"var_type": "Int", "var_description": "A redirect was specified by way of server response code, but the server did not accompany this code with a redirect URL.", "var_name": "NSURLErrorRedirectToNonExistentLocation"}, {"var_type": "Int", "var_description": "A body stream was needed but the client did not provide one.  This impacts clients on iOS that send a POST request using a body stream but do not implement the URLSessionTaskDelegate delegate method urlSession(_:task:needNewBodyStream:).", "var_name": "NSURLErrorRequestBodyStreamExhausted"}, {"var_type": "Int", "var_description": "A requested resource couldn\u2019t be retrieved.", "var_name": "NSURLErrorResourceUnavailable"}, {"var_type": "Int", "var_description": "An attempt to establish a secure connection failed for reasons that can\u2019t be expressed more specifically.", "var_name": "NSURLErrorSecureConnectionFailed"}, {"var_type": "Int", "var_description": "A server certificate had a date which indicated it had expired, or is not yet valid.", "var_name": "NSURLErrorServerCertificateHasBadDate"}, {"var_type": "Int", "var_description": "A server certificate was not signed by any root server.", "var_name": "NSURLErrorServerCertificateHasUnknownRoot"}, {"var_type": "Int", "var_description": "A server certificate is not yet valid.", "var_name": "NSURLErrorServerCertificateNotYetValid"}, {"var_type": "Int", "var_description": "A server certificate was signed by a root server that isn\u2019t trusted.", "var_name": "NSURLErrorServerCertificateUntrusted"}, {"var_type": "Int", "var_description": "An asynchronous operation timed out. ", "var_name": "NSURLErrorTimedOut"}, {"var_type": "Int", "var_description": "The URL Loading System encountered an error that it can\u2019t interpret.", "var_name": "NSURLErrorUnknown"}, {"var_type": "Int", "var_description": "A properly formed URL couldn\u2019t be handled by the framework.", "var_name": "NSURLErrorUnsupportedURL"}, {"var_type": "Int", "var_description": "Authentication was required to access a resource.", "var_name": "NSURLErrorUserAuthenticationRequired"}, {"var_type": "Int", "var_description": "An asynchronous request for authentication has been canceled by the user.", "var_name": "NSURLErrorUserCancelledAuthentication"}, {"var_type": "Int", "var_description": "A server reported that a URL has a non-zero content length, but terminated the network connection gracefully without sending any data.", "var_name": "NSURLErrorZeroByteResource"}], "subclass_list": [], "class_description": "Objective-C methods can signal an error condition by returning an NSError object by reference, which provides additional information about the kind of error and any underlying cause, if one can be determined. An NSError object may also provide localized error descriptions suitable for display to the user in its user info dictionary. See Error Handling Programming Guide for more information.\nMethods in Foundation and other Cocoa frameworks most often produce errors in the Cocoa error domain (NSCocoaErrorDomain); error codes for the Cocoa Error Domain are documented in the Foundation Constants. There are also predefined domains corresponding to Mach (NSMachErrorDomain), POSIX (NSPOSIXErrorDomain), and Carbon (NSOSStatusErrorDomain) errors.\nNSError is \u201ctoll-free bridged\u201d with its Core Foundation counterpart, CFError. See Toll-Free Bridging for more information.\nApplications may choose to create subclasses of NSError, for example, to provide better localized error strings by overriding localizedDescription.\n", "class_name": "NSError"}