{"class_inherit_list": [], "Vars": [{"var_description": "The wrapped value of this instance, unwrapped without checking whether the instance is nil.", "var_type": "Wrapped", "var_name": "unsafelyUnwrapped"}, {"var_description": "A textual representation of this instance, suitable for debugging.", "var_type": "String", "var_name": "debugDescription"}, {"var_description": "", "var_type": "Mirror", "var_name": "customMirror"}], "class_name": "Optional", "interface_list": ["CustomDebugStringConvertible", "CustomReflectable", "Decodable", "Encodable", "Equatable", "ExpressibleByNilLiteral", "Hashable"], "subclass_list": [], "class_description": "You use the Optional type whenever you use optional values, even if you never type the word Optional. Swift\u2019s type system usually shows the wrapped type\u2019s name with a trailing question mark (?) instead of showing the full type name. For example, if a variable has the type Int?, that\u2019s just another way of writing Optional<Int>. The shortened form is preferred for ease of reading and writing code.\nThe types of shortForm and longForm in the following code sample are the same:\nThe Optional type is an enumeration with two cases. Optional.none is equivalent to the nil literal. Optional.some(Wrapped) stores a wrapped value. For example:\nYou must unwrap the value of an Optional instance before you can use it in many contexts. Because Swift provides several ways to safely unwrap optional values, you can choose the one that helps you write clear, concise code.\nThe following examples use this dictionary of image names and file paths:\nGetting a dictionary\u2019s value using a key returns an optional value, so imagePaths[\"star\"] has type Optional<String> or, written in the preferred manner, String?.\nTo conditionally bind the wrapped value of an Optional instance to a new variable, use one of the optional binding control structures, including if let, guard let, and switch.\nTo safely access the properties and methods of a wrapped instance, use the postfix optional chaining operator (postfix ?). The following example uses optional chaining to access the hasSuffix(_:) method on a String? instance.\nUse the nil-coalescing operator (??) to supply a default value in case the Optional instance is nil. Here a default path is supplied for an image that is missing from imagePaths.\nThe ?? operator also works with another Optional instance on the right-hand side. As a result, you can chain multiple ?? operators together.\nWhen you\u2019re certain that an instance of Optional contains a value, you can unconditionally unwrap the value by using the forced unwrap operator (postfix !). For example, the result of the failable Int initializer is unconditionally unwrapped in the example below.\nYou can also perform unconditional optional chaining by using the postfix ! operator.\nUnconditionally unwrapping a nil instance with ! triggers a runtime error.\n", "Methods": [{"return_value": {"return_description": ["The result of the given closure. If this instance is nil, returns nil."], "return_name": [""], "return_type": ["U rethrows -> U"]}, "method_description": "Evaluates the given closure when this Optional instance is not nil, passing the unwrapped value as a parameter.", "method_name": "map", "class_name": "Optional", "params": [{"param_description": "A closure that takes the unwrapped value of the instance.", "param_type": "(Wrapped", "param_name": ["transform"]}]}, {"return_value": {"return_description": ["The result of the given closure. If this instance is nil, returns nil."], "return_name": [""], "return_type": ["U rethrows -> U"]}, "method_description": "Evaluates the given closure when this Optional instance is not nil, passing the unwrapped value as a parameter.", "method_name": "flatMap", "class_name": "Optional", "params": [{"param_description": "A closure that takes the unwrapped value of the instance.", "param_type": "(Wrapped", "param_name": ["transform"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["T rethrows -> T"]}, "method_description": "Performs a nil-coalescing operation, returning the wrapped value of an Optional instance or a default value.", "method_name": "", "class_name": "Optional", "params": [{"param_description": "An optional value.", "param_type": "T", "param_name": ["optional"]}, {"param_description": "A value to use as a default. defaultValue is the same type as the Wrapped type of optional.", "param_type": "@autoclosure (", "param_name": ["defaultValue"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["T rethrows -> T"]}, "method_description": "Performs a nil-coalescing operation, returning the wrapped value of an Optional instance or a default Optional value.", "method_name": "", "class_name": "Optional", "params": [{"param_description": "An optional value.", "param_type": "T", "param_name": ["optional"]}, {"param_description": "A value to use as a default. defaultValue and optional have the same type.", "param_type": "@autoclosure (", "param_name": ["defaultValue"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two optional instances are equal.", "method_name": "==", "class_name": "Optional", "params": [{"param_description": "An optional value to compare.", "param_type": "Wrapped", "param_name": ["lhs"]}, {"param_description": "Another optional value to compare.", "param_type": "Wrapped", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two optional instances are not equal.", "method_name": "!=", "class_name": "Optional", "params": [{"param_description": "An optional value to compare.", "param_type": "Wrapped", "param_name": ["lhs"]}, {"param_description": "Another optional value to compare.", "param_type": "Wrapped", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "class_name": "Optional", "params": [{"param_description": "A value to compare.", "param_type": "Optional<Wrapped>", "param_name": ["lhs"]}, {"param_description": "Another value to compare.", "param_type": "Optional<Wrapped>", "param_name": ["rhs"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Encodes this optional value into the given encoder.", "method_name": "encode", "class_name": "Optional", "params": [{"param_description": "The encoder to write data to.", "param_type": "Encoder", "param_name": ["to", "encoder"]}]}, {"return_value": {"return_description": [], "return_name": [], "return_type": []}, "method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "class_name": "Optional", "params": [{"param_description": "The hasher to use when combining the components of this instance.", "param_type": "inout Hasher", "param_name": ["into", "hasher"]}]}], "package_name": "swift"}