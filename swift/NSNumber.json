{"package_name": "foundation", "interface_list": ["CKRecordValueProtocol", "CVarArg", "Equatable", "ExpressibleByBooleanLiteral", "ExpressibleByFloatLiteral", "ExpressibleByIntegerLiteral", "Hashable", "NSFetchRequestResult"], "class_inherit_list": ["NSValue"], "Methods": [{"return_value": {"return_type": ["String"], "return_name": [""], "return_description": ["A string that represents the contents of the number object formatted using the locale information in locale."]}, "method_name": "description", "class_name": "NSNumber", "method_description": "Returns a string that represents the contents of the number object for a given locale.", "params": [{"param_type": "Any", "param_name": ["withLocale", "locale"], "param_description": ""}]}, {"return_value": {"return_type": ["ComparisonResult"], "return_name": [""], "return_description": ["NSOrderedAscending if the value of aNumber is greater than the number object\u2019s, NSOrderedSame if they\u2019re equal, and NSOrderedDescending if the value of aNumber is less than the number object\u2019s."]}, "method_name": "compare", "class_name": "NSNumber", "method_description": "Returns an NSComparisonResult value that indicates whether the number object\u2019s value is greater than, equal to, or less than a given number.", "params": [{"param_type": "NSNumber", "param_name": ["otherNumber"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["true if the number object\u2019s value and aNumber are equal, otherwise false."]}, "method_name": "isEqual", "class_name": "NSNumber", "method_description": "Returns a Boolean value that indicates whether the number object\u2019s value and a given number are equal. ", "params": [{"param_type": "NSNumber", "param_name": ["to", "number"], "param_description": ""}]}, {"return_value": {"return_type": ["Bool"], "return_name": [""], "return_description": ["false if the value in dcm represents a valid number, otherwise true."]}, "method_name": "NSDecimalIsNotANumber", "class_name": "NSNumber", "method_description": "Returns a Boolean that indicates whether a given decimal contains a valid number.", "params": [{"param_type": "UnsafePointer<Decimal>", "param_name": ["dcm"], "param_description": ""}]}], "Vars": [{"var_type": "Bool", "var_description": "The number object's value expressed as a Boolean value.", "var_name": "boolValue"}, {"var_type": "Int8", "var_description": "The number object's value expressed as a char.", "var_name": "int8Value"}, {"var_type": "Decimal", "var_description": "The number object's value expressed as an Decimal structure.", "var_name": "decimalValue"}, {"var_type": "Double", "var_description": "The number object's value expressed as a double, converted as necessary.", "var_name": "doubleValue"}, {"var_type": "Float", "var_description": "The number object's value expressed as a float, converted as necessary.", "var_name": "floatValue"}, {"var_type": "Int32", "var_description": "The number object's value expressed as an int, converted as necessary.", "var_name": "int32Value"}, {"var_type": "Int", "var_description": "The number object's value expressed as an NSInteger object, converted as necessary.", "var_name": "intValue"}, {"var_type": "Int64", "var_description": "The number object\u2019s value expressed as a long long, converted as necessary.", "var_name": "int64Value"}, {"var_type": "Int16", "var_description": "The number object's value expressed as a short, converted as necessary.", "var_name": "int16Value"}, {"var_type": "UInt8", "var_description": "The number object's value expressed as an unsigned char, converted as necessary.", "var_name": "uint8Value"}, {"var_type": "UInt", "var_description": "The number object's value expressed as an NSUInteger object, converted as necessary.", "var_name": "uintValue"}, {"var_type": "UInt32", "var_description": "The number object's value expressed as an unsigned int, converted as necessary.", "var_name": "uint32Value"}, {"var_type": "UInt64", "var_description": "The number object\u2019s value expressed as an unsigned long long, converted as necessary.", "var_name": "uint64Value"}, {"var_type": "UInt16", "var_description": "The number object's value expressed as an unsigned short, converted as necessary.", "var_name": "uint16Value"}, {"var_type": "String", "var_description": "The number object's value expressed as a human-readable string.", "var_name": "stringValue"}], "subclass_list": [], "class_description": "NSNumber is a subclass of NSValue that offers a value as any C scalar (numeric) type. It defines a set of methods specifically for setting and accessing the value as a signed or unsigned char, short int, int, long int, long long int, float, or double or as a BOOL. (Note that number objects do not necessarily preserve the type they are created with.) It also defines a compare(_:) method to determine the ordering of two NSNumber objects.\nNSNumber is \u201ctoll-free bridged\u201d with its Core Foundation counterparts: CFNumber for integer and floating point values, and CFBoolean for Boolean values. See Toll-Free Bridging for more information on toll-free bridging.\nNSNumber provides readonly properties that return the object\u2019s stored value converted to a particular Boolean, integer, unsigned integer, or floating point C scalar type. Because numeric types have different storage capabilities, attempting to initialize with a value of one type and access the value of another type may produce an erroneous result\u2014for example, initializing with a double value exceeding FLT_MAX and accessing its floatValue, or initializing with an negative integer value and accessing its uintValue. In some cases, attempting to initialize with a value of a type and access the value of another type may result in loss of precision\u2014for example, initializing with a double value with many significant digits and accessing its floatValue, or initializing with a large integer value and accessing its int8Value.\nAn NSNumber object initialized with a value of a particular type accessing the converted value of a different kind of type, such as unsigned int and float, will convert its stored value to that converted type in the following ways:\nNSNumber from Boolean Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\nfalse\nfalse\n0\n0\n0.0\ntrue\ntrue\n1\n1\n1.0\nNSNumber from Integer Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\n0\nfalse\n0\n0\n0.0\n1\ntrue\n1\n1\n1.0\n-1\ntrue\n-1\ninvalid, erroneous result\n-1.0\nNSNumber from Unsigned Integer Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\n0\nfalse\n0\n0\n0.0\n1\ntrue\n1\n1\n1.0\nNSNumber from Floating Point Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\n0.0\nfalse\n0\n0\n0.0\n1.0\ntrue\n1\n1\n1.0\n-1.0\ntrue\n-1\ninvalid, erroneous result\n-1.0\nAs with any class cluster, subclasses of NSNumber must override the primitive methods of its superclass, NSValue. In addition, there are two requirements around the data type your subclass represents:\nYour implementation of objCType must return one of \u201cc\u201d, \u201cC\u201d, \u201cs\u201d, \u201cS\u201d, \u201ci\u201d, \u201cI\u201d, \u201cl\u201d, \u201cL\u201d, \u201cq\u201d, \u201cQ\u201d, \u201cf\u201d, and \u201cd\u201d. This is required for the other methods of NSNumber to behave correctly.\nYour subclass must override the accessor method that corresponds to the declared type\u2014for example, if your implementation of objCType returns  \u201ci\u201d, you must override int32Value.\n", "class_name": "NSNumber"}